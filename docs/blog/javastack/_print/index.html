<!doctype html>
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.89.4" /><link rel="canonical" type="text/html" href="https://capa-cloud.github.io/capa.io/blog/javastack/">
<link rel="alternate" type="application/rss&#43;xml" href="https://capa-cloud.github.io/capa.io/blog/javastack/index.xml">
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="shortcut icon" href="/capa.io/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/capa.io/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="/capa.io/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/capa.io/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/capa.io/favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="/capa.io/favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="/capa.io/favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="/capa.io/favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="/capa.io/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/capa.io/favicons/android-192x192.png" sizes="192x192">

<title>Cloud Java Stack | Capa</title>


  
  <meta name="description" content="Capa主要面向Java语言进行设计。
Capa本身不提供功能，而是由底层的各种中间件的Java SDK来提供。
所以了解Java中常用中间件的设计是很有必要的。
本目录主要为对Java生态中中间件的学习和实践。
">
<meta property="og:title" content="Cloud Java Stack" />
<meta property="og:description" content="Cloud Runtimes API" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://capa-cloud.github.io/capa.io/blog/javastack/" /><meta property="og:site_name" content="Capa" />

<meta itemprop="name" content="Cloud Java Stack">
<meta itemprop="description" content="Cloud Runtimes API"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cloud Java Stack"/>
<meta name="twitter:description" content="Cloud Runtimes API"/>




<link rel="preload" href="/capa.io/scss/main.min.bd5285b713d3061549a6bfd34e5f4ec6775ede36672a3088260f0d420050647f.css" as="style">
<link href="/capa.io/scss/main.min.bd5285b713d3061549a6bfd34e5f4ec6775ede36672a3088260f0d420050647f.css" rel="stylesheet" integrity="">


<script
  src="https://code.jquery.com/jquery-3.5.1.min.js"
  integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
  crossorigin="anonymous"></script>







<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-00000000-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




  </head>
  <body class="td-section td-blog">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
        <a class="navbar-brand" href="/capa.io/">
		<span class="navbar-logo"></span><span class="text-uppercase font-weight-bold">Capa</span>
	</a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/capa.io/about/" ><span>关于</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/capa.io/docs/" ><span>文档</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link active" href="/capa.io/blog/" ><span class="active">博客</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="/capa.io/community/" ><span>社区</span></a>
			</li>
			
			
			
			<li class="nav-item dropdown mr-4 d-none d-lg-block">
				

<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	简体中文
</a>
<div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="/capa.io/en/">English</a>
	
</div>
			</li>
			
		</ul>
	</div>
	<div class="navbar-nav d-none d-lg-block">
<input type="search" class="form-control td-search-input" placeholder="&#xf002; 站内搜索…" aria-label="站内搜索…" autocomplete="off">

</div>
</nav>

    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href="#" onclick="print();return false;">点击此处打印</a>.
</p><p>
<a href="/capa.io/blog/javastack/">返回本页常规视图</a>.
</p>
</div>



<h1 class="title">Cloud Java Stack</h1>





    <ul>
    
  
  
  
  

  
    
    
	

    <li><a href="#pg-261f22b6a4e2fdb44edd3dd2f14c62ee">Dubbo Stack</a></li>



    
    <ul>
        
  
  
  
  

  
    
    
	

    <li><a href="#pg-967e9aa79f3ddac5796d87369f2bf268">Dubbo Invoke流程</a></li>



    
  
    
    
	

    <li><a href="#pg-1ee71be258b4e94974f165af524f9f7e">Dubbo Landscape</a></li>



    
  

    </ul>
    
  
    
    
	

    <li><a href="#pg-2db35c433bd5104121244ec7e04e6ddb">Java Web Stack</a></li>



    
    <ul>
        
  
  
  
  

  
    
    
	

    <li><a href="#pg-875e8b883dae1e4279177b7865a463f7">Java Servlet</a></li>



    
  
    
    
	

    <li><a href="#pg-f4745211e98160929b3645ba8e19175a">Java Spring</a></li>



    
  

    </ul>
    
  
    
    
	

    <li><a href="#pg-03d02d97bf9aa60a5c05b9cf56c91fbe">Netty Stack</a></li>



    
    <ul>
        
  
  
  
  

  
    
    
	

    <li><a href="#pg-614236e2a333c7391796cdcd24cbc4bc">Netty Channel设计</a></li>



    
  
    
    
	

    <li><a href="#pg-7d923a1561824f2a60d7ad00cfeb0d36">Netty Landscape</a></li>



    
  

    </ul>
    
  
    
    
	

    <li><a href="#pg-e862cad1bba3c9950e40928bb47c9a41">Reactive Stack</a></li>



    
    <ul>
        
  
  
  
  

  
    
    
	

    <li><a href="#pg-14e34b1064ac833217e025bb77c63fd2">Reactive Landscape</a></li>



    
  
    
    
	

    <li><a href="#pg-31eb92571f21035519def0085b835fc1">Reactive模式在Trip.com消息推送平台上的实践</a></li>



    
  
    
    
	

    <li><a href="#pg-f896adba4338c89b3a0b0e9b4ccf2de1">Reactive 数据流模型设计</a></li>



    
  

    </ul>
    
  

    </ul>


<div class="content">
      <p>Capa主要面向Java语言进行设计。</p>
<p>Capa本身不提供功能，而是由底层的各种中间件的Java SDK来提供。</p>
<p>所以了解Java中常用中间件的设计是很有必要的。</p>
<p>本目录主要为对Java生态中中间件的学习和实践。</p>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-261f22b6a4e2fdb44edd3dd2f14c62ee">Dubbo Stack</h1>
	
	<div class="td-byline mb-4">
		
        
	</div>
	
</div>





    
      
  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="">
    <h1 id="pg-967e9aa79f3ddac5796d87369f2bf268">Dubbo Invoke流程</h1>
	<div class="lead">Dubbo Invoke流程.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-22" class="text-muted">22.05.2022</time>
        
	</div>
	<h3 id="概要">概要</h3>
<p>梳理Dubbo的调用链路流程，分析其设计理念和思路，以及阅读其中关键步骤的源码逻辑</p>
<h4 id="review">Review</h4>
<blockquote>
<p>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</p>
</blockquote>
<p>调用流程主要围绕<code>Protocol</code>/<code>Invoker</code>/<code>Filter</code>三个接口进行</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Protocol</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">Exporter</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">export</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">refer</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Class</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">type</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">URL</span> <span style="color:#000">url</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroy</span><span style="color:#ce5c00;font-weight:bold">();</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">Node</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#000">Result</span> <span style="color:#000">invoke</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invocation</span> <span style="color:#000">invocation</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroy</span><span style="color:#ce5c00;font-weight:bold">();</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Filter</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">BaseFilter</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#000">Result</span> <span style="color:#000">invoke</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;?&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">Invocation</span> <span style="color:#000">invocation</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><h2 id="整体流程">整体流程</h2>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img.png" alt=""></p>
<h3 id="初始化流程">初始化流程</h3>
<ol>
<li>初始化配置相关&hellip;&hellip;.</li>
<li>初始化<code>Protocol</code></li>
<li>初始化<code>Invoker</code></li>
<li>初始化底层资源</li>
</ol>
<h3 id="调用流程">调用流程</h3>
<ol>
<li>调用<code>Invoker</code>，做一些逻辑</li>
<li>调用<code>Filter</code>，做一些逻辑</li>
<li>调用<code>Invoker</code>，做一些逻辑</li>
<li>调用底层资源</li>
</ol>
<h2 id="简化设计">简化设计</h2>
<p>从一个Client开始&hellip;&hellip;</p>
<h4 id="1-直接调用">1. 直接调用</h4>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_1.png" alt=""></p>
<h4 id="2-责任链模式">2. 责任链模式</h4>
<p>解决函数逻辑的水平拓展问题</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_2.png" alt=""></p>
<p>定义接口：<code>Response invoke(Request request);</code></p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">Node</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#000">Result</span> <span style="color:#000">invoke</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invocation</span> <span style="color:#000">invocation</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroy</span><span style="color:#ce5c00;font-weight:bold">();</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><h4 id="3-过滤器插件">3. 过滤器插件</h4>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_3.png" alt=""></p>
<h4 id="在重要的过程上设置拦截接口">在重要的过程上设置拦截接口</h4>
<p>如果你要写个远程调用框架，那远程调用的过程应该有一个统一的拦截接口。如果你要写一个 ORM 框架，那至少 SQL 的执行过程，Mapping 过程要有拦截接口；如果你要写一个 Web 框架，那请求的执行过程应该要有拦截接口，等等。没有哪个公用的框架可以 Cover 住所有需求，允许外置行为，是框架的基本扩展方式。这样，如果有人想在远程调用前，验证下令牌，验证下黑白名单，统计下日志；如果有人想在 SQL 执行前加下分页包装，做下数据权限控制，统计下 SQL 执行时间；如果有人想在请求执行前检查下角色，包装下输入输出流，统计下请求量，等等，就可以自行完成，而不用侵入框架内部。<strong>拦截接口，通常是把过程本身用一个对象封装起来，传给拦截器链，比如：远程调用主过程为 invoke()，那拦截器接口通常为 invoke(Invocation)，Invocation 对象封装了本来要执行过程的上下文，并且 Invocation 里有一个 invoke() 方法，由拦截器决定什么时候执行，同时，Invocation 也代表拦截器行为本身，这样上一拦截器的 Invocation 其实是包装的下一拦截器的过程，直到最后一个拦截器的 Invocation 是包装的最终的 invoke() 过程</strong>；同理，SQL 主过程为 execute()，那拦截器接口通常为 execute(Execution)，原理一样。当然，实现方式可以任意，上面只是举例。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Filter</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">BaseFilter</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#000">Result</span> <span style="color:#000">invoke</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;?&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">Invocation</span> <span style="color:#000">invocation</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><p><strong>装饰模式/组合模式</strong></p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_4.png" alt=""></p>
<h4 id="4-领域模型的设计">4. 领域模型的设计</h4>
<p><strong>重资源 -&gt; 资源的管理 -&gt; 生命周期</strong></p>
<p>资源的管理：</p>
<p>共享、创建、释放、生命周期&hellip;&hellip;..</p>
<p>链路治理、上下文、组装&hellip;&hellip;..</p>
<h4 id="领域模型">领域模型</h4>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_5.png" alt=""></p>
<p>在 Dubbo 的核心领域模型中：</p>
<ul>
<li>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</li>
<li>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li>
<li>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Protocol</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">Exporter</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">export</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">refer</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Class</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">type</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">URL</span> <span style="color:#000">url</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroy</span><span style="color:#ce5c00;font-weight:bold">();</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_6.png" alt=""></p>
<p>共享资源谁持有？</p>
<p>缓存在哪里存储？</p>
<p>线程安全？</p>
<p>单例还是New？</p>
<h4 id="服务域实体域会话域分离">服务域/实体域/会话域分离</h4>
<p>任何框架或组件，总会有核心领域模型，比如：Spring 的 Bean，Struts 的 Action，Dubbo 的 Service，Napoli 的 Queue 等等。这个核心领域模型及其组成部分称为实体域，它代表着我们要操作的目标本身。<strong>实体域通常是线程安全的，不管是通过不变类，同步状态，或复制的方式。</strong> ①</p>
<p>服务域也就是行为域，它是组件的功能集，同时也负责实体域和会话域的生命周期管理， 比如 Spring 的 ApplicationContext，Dubbo 的 ServiceManager 等。<strong>服务域的对象通常会比较重，而且是线程安全的，并以单一实例服务于所有调用。</strong> ②</p>
<p>什么是会话？就是一次交互过程。会话中重要的概念是上下文，什么是上下文？比如我们说：“老地方见”，这里的“老地方”就是上下文信息。为什么说“老地方”对方会知道，因为我们前面定义了“老地方”的具体内容。所以说，上下文通常持有交互过程中的状态变量等。<strong>会话对象通常较轻，每次请求都重新创建实例，请求结束后销毁。简而言之：把元信息交由实体域持有</strong>③，把一次请求中的临时状态由会话域持有，由服务域贯穿整个过程。</p>
<p>① <code>Invoker</code>仅维护自己的状态，类似Actor设计模式</p>
<p>② <code>Protocol</code>初始化为单例，并且持有缓存Map</p>
<p>③ <code>Invoker</code>中存储默认元信息，临时信息存储到<code>Invocation</code></p>
<p>=&gt; show code</p>
<h4 id="41-资源的销毁">4.1 资源的销毁</h4>
<p>由服务域管理资源的生命周期，并委托给实体域执行</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Protocol</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">Exporter</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">export</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">refer</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Class</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">type</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">URL</span> <span style="color:#000">url</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroy</span><span style="color:#ce5c00;font-weight:bold">();</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">Node</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#000">Result</span> <span style="color:#000">invoke</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invocation</span> <span style="color:#000">invocation</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroy</span><span style="color:#ce5c00;font-weight:bold">();</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><h4 id="42-状态的监听">4.2 状态的监听</h4>
<h4 id="重要的状态的变更发送事件并留出监听接口">重要的状态的变更发送事件并留出监听接口</h4>
<p>这里先要讲一个事件和上面拦截器的区别，拦截器是干预过程的，它是过程的一部分，是基于过程行为的，而事件是基于状态数据的，任何行为改变的相同状态，对事件应该是一致的。事件通常是事后通知，是一个 Callback 接口，方法名通常是过去式的，比如 onChanged()。比如远程调用框架，当网络断开或连上应该发出一个事件，当出现错误也可以考虑发出一个事件，这样外围应用就有可能观察到框架内部的变化，做相应适应。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">InvokerListener</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">referred</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;?&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">RpcException</span><span style="color:#ce5c00;font-weight:bold">;</span>

    <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">destroyed</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Invoker</span><span style="color:#ce5c00;font-weight:bold">&lt;?&gt;</span> <span style="color:#000">invoker</span><span style="color:#ce5c00;font-weight:bold">);</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><h4 id="43-纵向拓展">4.3 纵向拓展</h4>
<p>SPI，微内核，插件化</p>
<h4 id="微核插件式平等对待第三方">微核插件式，平等对待第三方</h4>
<p>大凡发展的比较好的框架，都遵守微核的理念。Eclipse 的微核是 OSGi， Spring 的微核是 BeanFactory，Maven 的微核是 Plexus。通常核心是不应该带有功能性的，而是一个生命周期和集成容器，这样各功能可以通过相同的方式交互及扩展，并且任何功能都可以被替换。如果做不到微核，至少要平等对待第三方，即原作者能实现的功能，扩展者应该可以通过扩展的方式全部做到。原作者要把自己也当作扩展者，这样才能保证框架的可持续性及由内向外的稳定性。</p>
<p>引入配置模块，担当微内核。并负责<code>Protocol</code>的初始化启动（Protocol再负责下层的初始化）</p>
<h4 id="44-完善的分层">4.4 完善的分层</h4>
<ul>
<li><strong>config 配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<p>其他层次以插件的方式装配到config里，核心仍然是<code>Protocol</code>层。功能要么伪装成<code>Invoker</code>，要么在初始化时进行。</p>
<blockquote>
<p>在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_7.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_8.png" alt=""></p>
<p>层级关系：</p>
<pre><code>-system
-config
-proxy
-registry
-cluster
-monitor
-protocol
    -invoker
        -exchange
        -...
</code></pre>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_9.png" alt=""></p>
<h4 id="5-异步调用">5. 异步调用</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Result</span> <span style="color:#204a87;font-weight:bold">extends</span> <span style="color:#000">Serializable</span> <span style="color:#ce5c00;font-weight:bold">{</span>

    <span style="color:#000">Result</span> <span style="color:#000">whenCompleteWithContext</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">BiConsumer</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">Result</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">Throwable</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">fn</span><span style="color:#ce5c00;font-weight:bold">);</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><h3 id="重点关注点">重点关注点</h3>
<p>结合一开始的大概流程&hellip;</p>
<h4 id="1-protocol初始化流程">1. protocol初始化流程</h4>
<p>初始化的时候做了什么？集群？注册发现？代理封装？</p>
<p>资源如何加载？如何缓存？连接池？线程池？</p>
<p>&hellip;&hellip;..</p>
<h4 id="2-invoke流程">2. invoke流程</h4>
<p>实际调用过程的流程？有哪些逻辑步骤？</p>
<p>负载均衡？重试？监控？序列化？</p>
<p>同步异步？流式调用？</p>
<p>&hellip;&hellip;..</p>
<h2 id="invoke流程解读">Invoke流程解读</h2>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_10.png" alt=""></p>
<h3 id="调用流程-1">调用流程</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_11.png" alt=""></p>
<h3 id="源码分析">源码分析</h3>
<p>关键Invoker的逻辑：</p>
<p><code>AbstractInvoker</code>: 3个步骤，（PR：https://github.com/apache/dubbo/pull/7952）</p>
<p>具体逻辑在<code>doInvoke</code>中</p>
<h4 id="failoverclusterinvoker"><code>FailoverClusterInvoker</code></h4>
<p>当调用失败时，记录初始错误并重试其他调用程序(重试n次，这意味着最多将调用n个不同的调用程序)注意，重试会导致延迟。 故障转移</p>
<p>图中方法：list、route、select</p>
<p>什么时候会重试？非biz异常，但粒度很粗&hellip;.（Issue相关）</p>
<h4 id="listenerinvokerwrapper"><code>ListenerInvokerWrapper</code></h4>
<p>注册invoker的listener，并进行操作，装饰模式</p>
<p>改进：观察者模式+生命周期</p>
<h4 id="filterchainnode"><code>FilterChainNode</code></h4>
<p>实际上是Invoker，但内部保存了Filter</p>
<p>Invoker装饰，Filter适配，两者的组合</p>
<h4 id="dubboinvoker"><code>DubboInvoker</code></h4>
<p>可以看到：Invoker层持有下层的资源管理</p>
<p>接下来就是<code>excahnge</code>层的逻辑</p>
<h4 id="tripleinvoker"><code>TripleInvoker</code></h4>
<p>直接持有底层netty资源，比较粗糙</p>
<p>=&gt; show code</p>
<h2 id="总结">总结</h2>
<h3 id="1层次结构">1.层次结构</h3>
<p>层级关系：</p>
<pre><code>-system
-config
-proxy
-registry
-cluster
-monitor
-protocol
    -invoker
        -exchange
        -...
</code></pre>
<h3 id="2调用流程">2.调用流程</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_12.png" alt=""></p>
<h3 id="3设计模式">3.设计模式</h3>
<p>责任链：Invoker</p>
<p>适配器：适配到Invoker责任链中</p>
<p>装饰：对Invoker进行增强</p>
<p>&hellip;&hellip;&hellip;</p>
<h3 id="4设计优化">4.设计优化</h3>
<p>Invoker调用链：√，整个系统的核心，插件化功能采用拓展接口的方式，各个模块功能比较明确</p>
<p>Lifecycle生命周期：不完全，没有完整的生命周期；对于生命周期的事件处理比较硬编码</p>
<p>Listener：装饰的比较硬编码，事件阶段不够全，拓展性不够好</p>
<p>Filter：采用装饰模型而非组合模型，拓展性较差；嵌套层级深，调试时链路不清晰</p>
<p>&hellip;&hellip;..</p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-1ee71be258b4e94974f165af524f9f7e">Dubbo Landscape</h1>
	<div class="lead">Dubbo Landscape.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-22" class="text-muted">22.05.2022</time>
        
	</div>
	<h2 id="一dubbo整体设计概述">一、Dubbo整体设计概述</h2>
<h3 id="ainvoker责任链设计">A、Invoker责任链设计</h3>
<h3 id="bfilter拓展机制设计">B、Filter拓展机制设计</h3>
<h3 id="cmanager容器管理设计">C、Manager容器管理设计</h3>
<h3 id="dlistener监听器设计">D、Listener监听器设计</h3>
<h3 id="elifecycle生命周期设计">E、Lifecycle生命周期设计</h3>
<h2 id="二设计思想">二、设计思想</h2>
<h3 id="a可拓展架构">A、可拓展架构</h3>
<p>SPI，微内核，插件化</p>
<h3 id="b设计模式">B、设计模式</h3>
<p>装饰器模式</p>
<p>责任链模式</p>
<h3 id="cddd设计">C、DDD设计</h3>

</div>





    
	
  

    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-2db35c433bd5104121244ec7e04e6ddb">Java Web Stack</h1>
	
	<div class="td-byline mb-4">
		
        
	</div>
	
</div>





    
      
  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="">
    <h1 id="pg-875e8b883dae1e4279177b7865a463f7">Java Servlet</h1>
	<div class="lead">Java Servlet的一些实践经验.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-30" class="text-muted">30.05.2022</time>
        
	</div>
	<h3 id="a初始化">A、初始化</h3>
<blockquote>
<p><a href="https://www.codetd.com/en/article/13249666#ServletContextListener_27">https://www.codetd.com/en/article/13249666#ServletContextListener_27</a></p>
</blockquote>
<h4 id="servletcontextlistener">ServletContextListener</h4>
<p>ServletContextListener 接口，它能够监听 ServletContext 对象的生命周期，当Servlet 容器启动或终止Web 应用时，会触发ServletContextEvent 事件，该事件由ServletContextListener 来处理。</p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-f4745211e98160929b3645ba8e19175a">Java Spring</h1>
	<div class="lead">Java Spring的一些实践经验.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-30" class="text-muted">30.05.2022</time>
        
	</div>
	<h3 id="a初始化">A、初始化</h3>
<blockquote>
<p><a href="https://www.codetd.com/en/article/13249666#ServletContextListener_27">https://www.codetd.com/en/article/13249666#ServletContextListener_27</a></p>
</blockquote>
<h4 id="beanpostprocessor">BeanPostProcessor</h4>
<p>Spring容器的创建Bean前后执行</p>
<h4 id="initializingbean">InitializingBean</h4>
<p>InitializingBean接口为bean提供了属性初始化后的处理方法，在bean的属性初始化后都会执行该方法。</p>
<h4 id="postconstruct">PostConstruct</h4>
<p>使用@PostConstruct注解一个方法来完成初始化，@PostConstruct注解的方法将会在依赖注入完成后被自动调用。</p>
<h4 id="applicationrunner和commandlinerunner">ApplicationRunner和CommandLineRunner</h4>
<p>项目启动后执行，CommandLineRunner和ApplicationRunner的作用是相同的，不同在于参数的封装和没封装。可以创建多个实现CommandLineRunner和ApplicationRunner接口的类。为了使他们按一定顺序执行，可以使用@Order注解或实现Ordered接口。</p>
<h4 id="执行顺序结果">执行顺序结果</h4>
<pre><code>.   ____          _            __ _ _
/\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
\\/  ___)| |_)| | | | | || (_| |  ) ) ) )
'  |____| .__|_| |_|_| |_\__, | / / / /
=========|_|==============|___/=/_/_/_/
:: Spring Boot ::        (v1.5.9.RELEASE)

beanPostProcessor run...
servletContextListener run...
initializingBean run...
postConstruct run...
applicationRunner run...
commandLineRunner run...</code></pre>

</div>





    
	
  

    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-03d02d97bf9aa60a5c05b9cf56c91fbe">Netty Stack</h1>
	
	<div class="td-byline mb-4">
		
        
	</div>
	
</div>





    
      
  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="">
    <h1 id="pg-614236e2a333c7391796cdcd24cbc4bc">Netty Channel设计</h1>
	<div class="lead">Netty Channel设计.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-20" class="text-muted">20.05.2022</time>
        
	</div>
	<h2 id="一整体流程概览">一、整体流程概览</h2>
<p>&hellip;&hellip;</p>
<h3 id="11-启动流程">1.1 启动流程</h3>
<h3 id="server端">Server端</h3>
<h4 id="1-创建handler">1. 创建Handler</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">EchoServerHandler</span> <span style="color:#000">serverHandler</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">EchoServerHandler</span><span style="color:#ce5c00;font-weight:bold">()</span>
</code></pre></div><p>Handler类结构图：</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img.png" alt=""></p>
<h4 id="2-创建eventloopgroup">2. 创建EventLoopGroup</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">EventLoopGroup</span> <span style="color:#000">group</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">NioEventLoopGroup</span><span style="color:#ce5c00;font-weight:bold">();</span>
</code></pre></div><p>EventLoopGroup类结构图：</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_1.png" alt=""></p>
<h4 id="21-创建group下面的eventloop">2.1 创建Group下面的EventLoop</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#5c35cc;font-weight:bold">@Override</span>
<span style="color:#204a87;font-weight:bold">protected</span> <span style="color:#000">EventLoop</span> <span style="color:#000">newChild</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Executor</span> <span style="color:#000">executor</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">Object</span><span style="color:#ce5c00;font-weight:bold">...</span> <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#204a87;font-weight:bold">throws</span> <span style="color:#000">Exception</span> <span style="color:#ce5c00;font-weight:bold">{</span>
    <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">NioEventLoop</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">executor</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">SelectorProvider</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#000">0</span><span style="color:#ce5c00;font-weight:bold">],</span>
        <span style="color:#ce5c00;font-weight:bold">((</span><span style="color:#000">SelectStrategyFactory</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#000">1</span><span style="color:#ce5c00;font-weight:bold">]).</span><span style="color:#c4a000">newSelectStrategy</span><span style="color:#ce5c00;font-weight:bold">(),</span> <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">RejectedExecutionHandler</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#000">args</span><span style="color:#ce5c00;font-weight:bold">[</span><span style="color:#000">2</span><span style="color:#ce5c00;font-weight:bold">]);</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_2.png" alt=""></p>
<h4 id="22-创建eventloop">2.2 创建EventLoop</h4>
<ul>
<li>
<p><code>taskQueue</code>: <code>MpscChunkedArrayQueue</code></p>
</li>
<li>
<p><code>tailQueue</code>: <code>MpscChunkedArrayQueue</code></p>
</li>
<li>
<p><code>selectNowSupplier</code>: <code>selector.selectNow()</code></p>
</li>
<li>
<p><code>pendingTasksCallable</code>: <code>super.pendingTasks() + tailTasks.size()</code></p>
</li>
<li>
<p><code>selectProvider</code>: <code>SelectorProvider.provider()</code></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_3.png" alt=""></p>
<h4 id="3-创建引导">3. 创建引导</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">ServerBootstrap</span> <span style="color:#000">b</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">ServerBootstrap</span><span style="color:#ce5c00;font-weight:bold">();</span>
</code></pre></div><p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_4.png" alt=""></p>
<h4 id="31-初始化一个channel">3.1 初始化一个Channel</h4>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_5.png" alt=""></p>
<h4 id="4-bind流程">4. bind流程</h4>
<h4 id="41-初始化一个channel">4.1 初始化一个Channel</h4>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_6.png" alt=""></p>
<p>持有底层的SocketChannel:(此处的Channel为java.nio的Channel)</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_7.png" alt=""></p>
<h4 id="42-初始化channelpipeline">4.2 初始化ChannelPipeline</h4>
<p>创建一个<code>DefaultChannelPipeline</code>:</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_8.png" alt=""></p>
<p>Channel和ChannelPipeline是双向绑定的关系，向ChannelPipeline中通过<code>addLast</code>方法添加Handler。
将ChannelHandler包装进入ChannelContext, 然后ChannelPipeline持有ChannelContext的双向链表：</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_9.png" alt=""></p>
<h4 id="43-注册channelfuture">4.3 注册ChannelFuture</h4>
<p>ChannelFuture：对Channel的各个生命周期阶段注册回调</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_10.png" alt=""></p>
<p>调用的是<code>AbstractChannel</code>的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">final</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">register</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">EventLoop</span> <span style="color:#000">eventLoop</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#204a87;font-weight:bold">final</span> <span style="color:#000">ChannelPromise</span> <span style="color:#000">promise</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">{</span>
</code></pre></div><p>然后是:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">eventLoop</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">execute</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">Runnable</span><span style="color:#ce5c00;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">{</span>
    <span style="color:#5c35cc;font-weight:bold">@Override</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">run</span><span style="color:#ce5c00;font-weight:bold">()</span> <span style="color:#ce5c00;font-weight:bold">{</span>
        <span style="color:#000">register0</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">promise</span><span style="color:#ce5c00;font-weight:bold">);</span>
    <span style="color:#ce5c00;font-weight:bold">}</span>
<span style="color:#ce5c00;font-weight:bold">});</span>
</code></pre></div><p>eventloop在这里是前面创建的EventLoopGroup</p>
<h4 id="44-register0解析">4.4 register0()解析</h4>
<ol>
<li>pipeline.invokeHandlerAddedIfNeeded();</li>
</ol>
<p>执行前面注册的ChannelHandler初始化initChannel的动作</p>
<ol start="2">
<li>第一个Handler执行完成后，会再次提交一个Runnable给EventLoop</li>
</ol>
<p><code>ServerBootstrapAcceptor</code></p>
<ol start="3">
<li>EventLoop不断执行Task（该部分需要细化）</li>
</ol>
<p>最终进入bind()操作，执行<code>ServerSocketChannelImpl.bind()</code></p>
<hr>
<h3 id="client端">Client端</h3>
<h4 id="1-启动流程">1. 启动流程</h4>
<p>同Server</p>
<h4 id="2-connect流程">2. connect流程</h4>
<ol>
<li>
<p>connect操作会注册一个task给eventloop</p>
</li>
<li>
<p>eventloop执行task:</p>
<p><code>Bootstrap.doResolveAndConnect0()</code></p>
</li>
<li>
<p>doConnect()</p>
</li>
<li>
<p>channel.connect()</p>
</li>
<li>
<p>SocketChannelImpl.connect()</p>
</li>
<li>
<p>interestOps置为8</p>
</li>
</ol>
<h4 id="3-clienthandler">3. ClientHandler</h4>
<ol>
<li>channelActive()</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_11.png" alt=""></p>
<ol start="2">
<li>channelRead()</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_12.png" alt=""></p>
<hr>
<h3 id="12-事件驱动模型设计">1.2 事件驱动模型设计</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_13.png" alt=""></p>
<p>主要包括4个基本组件：</p>
<p>事件队列（event queue）：接收事件的入口，存储待处理事件</p>
<p>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</p>
<p>事件通道（event channel）：分发器与处理器之间的联系渠道</p>
<p>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</p>
<p>可以看出，相对传统轮询模式，事件驱动有如下优点：</p>
<ul>
<li>可扩展性好，分布式的异步架构，事件处理器之间高度解耦，可以方便扩展事件处理逻辑</li>
<li>高性能，基于队列暂存事件，能方便并行异步处理事件</li>
</ul>
<blockquote>
<p>在同一组会话/链接中，将会触发不同的事件入口时，适合事件驱动架构</p>
</blockquote>
<h2 id="二主要模块">二、主要模块</h2>
<h3 id="21-reactor线程模型">2.1 Reactor线程模型</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_14.png" alt=""></p>
<p>1）Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，也可以叫做 BossNioEventLoopGroup 和 WorkerNioEventLoopGroup。每个线程池中都有 NioEventLoop 线程。BossGroup 中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写。BossGroup 和 WorkerGroup 的类型都是 NioEventLoopGroup。</p>
<p>2）NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每个事件循环就是一个 NioEventLoop。</p>
<p>3）NioEventLoop 表示一个不断循环的执行事件处理的线程，每个 NioEventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）。</p>
<p>4）NioEventLoopGroup 可以含有多个线程，即可以含有多个 NioEventLoop。</p>
<p>5）每个 BossNioEventLoop 中循环执行以下三个步骤：</p>
<p>5.1）select：轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）</p>
<p>5.2）processSelectedKeys：处理 accept 事件，与客户端建立连接，生成一个 NioSocketChannel，并将其注册到某个 WorkerNioEventLoop 上的 Selector 上</p>
<p>5.3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
<p>6）每个 WorkerNioEventLoop 中循环执行以下三个步骤：</p>
<p>6.1）select：轮训注册在其上的 NioSocketChannel 的 read/write 事件（OP_READ/OP_WRITE 事件）</p>
<p>6.2）processSelectedKeys：在对应的 NioSocketChannel 上处理 read/write 事件</p>
<p>6.3）runAllTasks：再去以此循环处理任务队列中的其他任务</p>
<p>7）在以上两个processSelectedKeys步骤中，会使用 Pipeline（管道），Pipeline 中引用了 Channel，即通过 Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。这里暂时不详细展开讲解 Pipeline。</p>
<h3 id="22-channelpipeline设计">2.2 ChannelPipeline设计</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_15.png" alt=""></p>
<p>1）Bootstrap 和 ServerBootstrap 分别是客户端和服务器端的引导类，一个 Netty 应用程序通常由一个引导类开始，主要是用来配置整个 Netty 程序、设置业务处理类（Handler）、绑定端口、发起连接等。</p>
<p>2）客户端创建一个 NioSocketChannel 作为客户端通道，去连接服务器。</p>
<p>3）服务端首先创建一个 NioServerSocketChannel 作为服务器端通道，每当接收一个客户端连接就产生一个 NioSocketChannel 应对该客户端。</p>
<p>4）使用 Channel 构建网络 IO 程序的时候，不同的协议、不同的阻塞类型和 Netty 中不同的 Channel 对应，常用的 Channel 有：</p>
<p>NioSocketChannel：非阻塞的 TCP 客户端 Channel（本案例的客户端使用的 Channel）
NioServerSocketChannel：非阻塞的 TCP 服务器端 Channel（本案例的服务器端使用的 Channel）
NioDatagramChannel：非阻塞的 UDP Channel
NioSctpChannel：非阻塞的 SCTP 客户端 Channel
NioSctpServerChannel：非阻塞的 SCTP 服务器端 Channel…</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/netty/img_16.png" alt=""></p>
<p>每个 Netty Channel 包含了一个 ChannelPipeline（其实 Channel 和 ChannelPipeline 互相引用），而 ChannelPipeline 又维护了一个由 ChannelHandlerContext 构成的双向循环列表，其中的每一个 ChannelHandlerContext 都包含一个 ChannelHandler。（前文描述的时候为了简便，直接说 ChannelPipeline 包含了一个 ChannelHandler 责任链，这里给出完整的细节。）</p>
<h3 id="23-channel模块设计">2.3 Channel模块设计</h3>
<h4 id="1-事件驱动--指令式设计--过程调用">1. 事件驱动 + 指令式设计 + 过程调用</h4>
<p>网络Channel对象 + 执行器 + 不同的事件处理器</p>
<p>processor.execute(channel(data), executor(executore))</p>
<h4 id="2-事件驱动--对象设计--责任链">2. 事件驱动 + 对象设计 + 责任链</h4>
<p>面向对象包装Channel：执行器、自身属性、操作定义</p>
<p>事件处理器责任链化：pipeline</p>
<p>事件处理器状态机：内部状态流转和外部状态触发
(好几套状态机&hellip;channel/pipeline/bootstrap&hellip;)</p>
<blockquote>
<p>内部状态流转的例子：register-&gt;register0-&gt;doregister &mdash;future完成后&mdash;&gt; bind-&gt;dobind0
内部状态流转：bind &ndash;&gt; pipeline.fireChannelActive &mdash;&gt; 一系列handler等内部状态流转 &mdash;&gt; read  &ndash;&gt; 注册read状态位 &ndash;&gt; 进入外部事件触发</p>
</blockquote>
<p>register: 接口定义，事件入口
register0: 抽象类封装（递交给eventloop）
doregister: 委托底层实现</p>
<h3 id="3-channel接口交互">3. channel接口交互</h3>
<pre><code>channel事件入口 ---&gt;递交给  channelpipeline（invoker定义链路操作）  ---&gt;链路入口   channelhandler执行具体链路方法
                                                               ---&gt;上下文    channelcontext
</code></pre>
<p>channelpipelint: invoker+链路组装</p>
<p>佐证：channelpipeline(invoker)和handler的方法一一对应
推测：context：面向对象的封装、另开一条链路</p>
<blockquote>
<p>ctx.fireChannelActive(); 链路控制</p>
</blockquote>
<p>责任链需要递归无用的handler，通过context直接指向下一个执行者，优化了流程</p>
<h2 id="三细节功能">三、细节功能</h2>
<h3 id="31-缓冲区零拷贝">3.1 缓冲区/零拷贝</h3>
<p>&hellip;&hellip;</p>
<h3 id="32-io异步机制">3.2 IO异步机制</h3>
<p>&hellip;&hellip;</p>
<h3 id="33-网络协议">3.3 网络协议</h3>
<p>&hellip;&hellip;</p>
<h3 id="参考文章">参考文章</h3>
<h4 id="io-模型">IO 模型</h4>
<p><a href="https://xie.infoq.cn/article/25d369e183563e44fc50d8168">https://xie.infoq.cn/article/25d369e183563e44fc50d8168</a></p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-7d923a1561824f2a60d7ad00cfeb0d36">Netty Landscape</h1>
	<div class="lead">Netty Landscape.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-20" class="text-muted">20.05.2022</time>
        
	</div>
	<h2 id="一netty整体设计概述">一、Netty整体设计概述</h2>
<h3 id="apipeline链设计">A、Pipeline链设计</h3>
<h3 id="b内外状态映射设计">B、内外状态映射设计</h3>
<h3 id="creactor线程模型">C、Reactor线程模型</h3>
<h3 id="d线程池分离">D、线程池分离</h3>
<p>Boss Worker</p>
<h2 id="二设计思想">二、设计思想</h2>
<h3 id="a可拓展架构">A、可拓展架构</h3>
<h3 id="b命令模式">B、命令模式</h3>
<p>将待执行操作包装成命令对象，投递给eventloop线程执行</p>

</div>





    
	
  

    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-e862cad1bba3c9950e40928bb47c9a41">Reactive Stack</h1>
	
	<div class="td-byline mb-4">
		
        
	</div>
	
</div>





    
      
  
  
  
  

  
  

  
    
    
	
    


  

<div class="td-content" style="">
    <h1 id="pg-14e34b1064ac833217e025bb77c63fd2">Reactive Landscape</h1>
	<div class="lead">Reactive Landscape.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-20" class="text-muted">20.05.2022</time>
        
	</div>
	<h2 id="一reactive-stream整体设计概述">一、Reactive Stream整体设计概述</h2>
<h3 id="a声明式编程">A、声明式编程</h3>
<h3 id="b延迟执行">B、延迟执行</h3>
<p>单流</p>
<h3 id="c反向组装">C、反向组装</h3>
<p>三流</p>
<h3 id="d背压反向订阅">D、背压(反向订阅)</h3>
<p>五流</p>
<h2 id="二设计思想">二、设计思想</h2>
<h3 id="a命令模式拓展">A、命令模式拓展</h3>
<p>将步骤抽象为Sink算子</p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-31eb92571f21035519def0085b835fc1">Reactive模式在Trip.com消息推送平台上的实践</h1>
	<div class="lead">Reactive模式在Trip.com消息推送平台上的实践.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-20" class="text-muted">20.05.2022</time>
        
	</div>
	<p>原文地址：https://zhuanlan.zhihu.com/p/392401566</p>

</div>





    
	
  
    
    
	
    


  

<div class="td-content" style="page-break-before: always">
    <h1 id="pg-f896adba4338c89b3a0b0e9b4ccf2de1">Reactive 数据流模型设计</h1>
	<div class="lead">reactor-core 数据流模型设计.</div>
	<div class="td-byline mb-4">
		
        
		<time datetime="2022-05-20" class="text-muted">20.05.2022</time>
        
	</div>
	<h1 id="反应式编程理论与reactor源码解析">反应式编程理论与Reactor源码解析</h1>
<h2 id="反应式编程理论">反应式编程理论</h2>
<h3 id="反应式宣言">反应式宣言</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img.png" alt=""></p>
<p>反应式宣言：<strong>异步</strong> <strong>非阻塞</strong> <strong>带回压</strong> 的方式进行流程控制</p>
<p>技术手段+表现形式：</p>
<ul>
<li>异步非阻塞 → 相比基于回调和Future的异步开发模型，通过函数式编程和声明式编程更加具有可编排性和可读性。</li>
<li>回压机制 → 通过订阅模型，组装数据流的流水线，下游订阅者可以反压源头，将“推送”模式转换为“推送+拉取”混合的模式。</li>
<li>事件驱动 → 应用内事件循环，使用EventLoop线程模型，能够做到异步非阻塞</li>
<li>消息驱动 → 分布式系统通信和协作，使用反应式的网络通信协议</li>
</ul>
<h3 id="反应式编程适用场景">反应式编程适用场景</h3>
<p>我们在选择使用反应式编程时，一定要明确它的适用场景，主要包括：</p>
<ul>
<li>处理由用户或其他系统发起的事件，如鼠标点击、键盘按键或者物联网设备等无时无刻都在发射信号的情况</li>
<li>处理磁盘或网络等高延迟的IO数据，且保证这些IO操作是异步的</li>
<li>业务的处理流程是流式的，且需要高响应的非阻塞操作</li>
</ul>
<h3 id="仍然没有免费的午餐">仍然没有免费的午餐</h3>
<p>首先，我们的代码是声明式的，不方便调试，错误发生时不容易定位。使用原生的API，例如不通过Spring框架而直接使用Reactor，会使情况变的更糟，因为我们自己要做很多的错误处理，每次进行网络调用都要写很多样板代码。通过组合使用 Spring 和 Reactor 我们可以方便的查看堆栈信息和未捕获的异常。由于运行的线程不受我们控制，因此在理解上会有困难。</p>
<p>其次，一旦编写错误导致一个Reactive回调被阻塞，在同一线程上的所有请求都会挂起。在servlet容器中，由于是一个请求一个线程，一个请求阻塞时，其它的请求不会受影响。而在Reactive中，一个请求被阻塞会导致所有请求的延迟都增加。</p>
<h2 id="一反应式编程库介绍">一、反应式编程库介绍</h2>
<p>实践反应式宣言的编程框架，提供开箱即用的反应式编程手段</p>
<h3 id="11-为什么要使用反应式编程库">1.1 为什么要使用反应式编程库？</h3>
<p>编写非阻塞、并发和可伸缩的代码是困难的。反应式编程库通过提供基于reactor模式的简单编程模型，提供了构建此类应用程序的最简单方法，这将允许应用程序高效地使用所有硬件资源。</p>
<p>相对于传统的基于回调和Future的异步开发方式，响应式编程更加具有可编排性和可读性，配合lambda表达式，代码更加简洁，处理逻辑的表达就像装配“流水线”，适用于对数据流的处理。</p>
<p>统一的编码方式，在不同的反应式网络协议和编程模型之上，构建了抽象编程层。例如gRPC和RSocket等反应式网络协议，无需了解具体协议细节，直接使用抽象层编程即可实现相关功能。</p>
<h3 id="12-反应式编程库示例">1.2 反应式编程库示例</h3>
<h4 id="主流反应式编程框架">主流反应式编程框架</h4>
<ul>
<li>Reactor-core</li>
<li>Spring-Webflux</li>
</ul>
<h4 id="其他反应式编程框架">其他反应式编程框架</h4>
<ul>
<li>RxJava</li>
</ul>
<h4 id="新兴反应式框架套件">新兴反应式框架套件</h4>
<ul>
<li>vert.x</li>
<li>Quarkus</li>
</ul>
<blockquote>
<p>静态编译技术：GraalVM/Android</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_1.png" alt=""></p>
<h3 id="13-反应式编程库和其他异步编程框架的对比">1.3 反应式编程库和其他异步编程框架的对比</h3>
<h4 id="java8">Java8</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">responseHandlerFuture</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">whenCompleteAsync</span><span style="color:#ce5c00;font-weight:bold">((</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">t</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#ce5c00;font-weight:bold">{</span>
        <span style="color:#204a87;font-weight:bold">if</span> <span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">t</span> <span style="color:#ce5c00;font-weight:bold">==</span> <span style="color:#204a87;font-weight:bold">null</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">{</span>
        <span style="color:#000">responseFuture</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">complete</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">r</span><span style="color:#ce5c00;font-weight:bold">);</span>
        <span style="color:#ce5c00;font-weight:bold">}</span> <span style="color:#204a87;font-weight:bold">else</span> <span style="color:#ce5c00;font-weight:bold">{</span>
        <span style="color:#000">responseFuture</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">completeExceptionally</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">t</span><span style="color:#ce5c00;font-weight:bold">);</span>
        <span style="color:#ce5c00;font-weight:bold">}</span>
<span style="color:#ce5c00;font-weight:bold">},</span> <span style="color:#000">futureCompletionExecutor</span><span style="color:#ce5c00;font-weight:bold">);</span>
</code></pre></div><h4 id="guava">Guava</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">responseFuture</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">addListener</span><span style="color:#ce5c00;font-weight:bold">(()</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#ce5c00;font-weight:bold">{...},</span> <span style="color:#000">rpcExecutorService</span><span style="color:#ce5c00;font-weight:bold">);</span>
</code></pre></div><h4 id="reactor">reactor</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8f5902;font-style:italic">// sending with async non-blocking io
</span><span style="color:#8f5902;font-style:italic"></span><span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">Mono</span>
        <span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">fromCompletionStage</span><span style="color:#ce5c00;font-weight:bold">(()</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#ce5c00;font-weight:bold">{</span>
            <span style="color:#8f5902;font-style:italic">// 注①
</span><span style="color:#8f5902;font-style:italic"></span>            <span style="color:#000">CompletableFuture</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">SendEmailResponse</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">responseFuture</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">awsAsyncClient</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">sendEmail</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">sendEmailRequest</span><span style="color:#ce5c00;font-weight:bold">);</span>
            <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#000">responseFuture</span><span style="color:#ce5c00;font-weight:bold">;</span>
        <span style="color:#ce5c00;font-weight:bold">})</span>
        <span style="color:#8f5902;font-style:italic">// 注② thread switching: callback executor
</span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#8f5902;font-style:italic">// .publishOn(asyncResponseScheduler)
</span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#8f5902;font-style:italic">// 注③ callback: success
</span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">map</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">response</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">onSuccess</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">context</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">response</span><span style="color:#ce5c00;font-weight:bold">))</span>
        <span style="color:#8f5902;font-style:italic">// 注④ callback: failure
</span><span style="color:#8f5902;font-style:italic"></span>        <span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">onErrorResume</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">throwable</span> <span style="color:#ce5c00;font-weight:bold">-&gt;</span> <span style="color:#ce5c00;font-weight:bold">{</span>
            <span style="color:#204a87;font-weight:bold">return</span> <span style="color:#204a87;font-weight:bold">this</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">onFailure</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">context</span><span style="color:#ce5c00;font-weight:bold">,</span> <span style="color:#000">throwable</span><span style="color:#ce5c00;font-weight:bold">);</span>
        <span style="color:#ce5c00;font-weight:bold">});</span>
</code></pre></div><h3 id="14-为啥不用java-stream来进行数据流的操作">1.4 为啥不用Java Stream来进行数据流的操作？</h3>
<p>原因在于，若将其用于响应式编程中，是有局限性的。比如如下两个需要面对的问题：</p>
<ul>
<li>Web 应用具有I/O密集的特点，I/O阻塞会带来比较大的性能损失或资源浪费，我们需要一种异步非阻塞的响应式的库，而Java Stream是一种同步API。</li>
<li>假设我们要搭建从数据层到前端的一个变化传递管道，可能会遇到数据层每秒上千次的数据更新，而显然不需要向前端传递每一次更新，这时候就需要一种流量控制能力，就像我们家里的水龙头，可以控制开关流速，而Java Stream不具备完善的对数据流的流量控制的能力。</li>
</ul>
<p>具备“异步非阻塞”特性和“流量控制”能力的数据流，我们称之为反应式流（Reactive Stream）。</p>
<h2 id="二反应式编程库原理">二、反应式编程库原理</h2>
<h3 id="21-编程理论">2.1 编程理论</h3>
<h4 id="函数式编程风格">函数式编程风格</h4>
<blockquote>
<p>就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。有很多支持函数式编程的程序语言，它们之间的具体设计都不完全一样。</p>
</blockquote>
<ol>
<li>延迟执行的</li>
<li>无副作用</li>
<li>不可变变量</li>
<li>并发编程</li>
</ol>
<h4 id="声明式编程风格">声明式编程风格</h4>
<ol>
<li>结合函数式编程</li>
<li>分隔函数算子，隔离副作用</li>
</ol>
<h4 id="反应式编程风格">反应式编程风格</h4>
<blockquote>
<p>响应式编程（reactive programming）是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。</p>
</blockquote>
<ol>
<li>函数式+声明式</li>
<li>延迟执行</li>
<li>背压</li>
<li>变化传递，推送</li>
</ol>
<blockquote>
<p>本质上都是java编程语言，主要区别在于编程风格和思考逻辑的不同</p>
</blockquote>
<h3 id="22-反应式库的核心接口">2.2 反应式库的核心接口</h3>
<p>组装数据流处理链的几种形式：</p>
<h4 id="1-链表形式">1. 链表形式</h4>
<p>面向过程</p>
<h4 id="2-观察者模式">2. 观察者模式</h4>
<p>面向对象</p>
<p>Publisher/Subscriber/Subctiption</p>
<p>java9</p>
<h4 id="publisher-即被观察者">Publisher 即被观察者</h4>
<p>Publisher 在 PRR 中 所承担的角色也就是传统的 观察者模式 中的 被观察者对象，在 PRR 的定义也极为简单。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">package</span> <span style="color:#000">org.reactivestreams</span><span style="color:#ce5c00;font-weight:bold">;</span>
<span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Publisher</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#ce5c00;font-weight:bold">{</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">subscribe</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Subscriber</span><span style="color:#ce5c00;font-weight:bold">&lt;?</span> <span style="color:#204a87;font-weight:bold">super</span> <span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">s</span><span style="color:#ce5c00;font-weight:bold">);</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><p>Publisher 的定义可以看出来，Publisher 接受 Subscriber，非常简单的一个接口。但是这里有个有趣的小细节，这个类所在的包是 org.reactivestreams，这里的做法和传统的 J2EE 标准类似，我们使用标准的 Javax 接口定义行为，不定义具体的实现。</p>
<h4 id="subscriber-即观察者">Subscriber 即观察者</h4>
<p>Subscriber 在 PRR 中 所承担的角色也就是传统的 观察者模式 中的 观察者对象，在 PRR 的定义要多一些。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Subscriber</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">T</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#ce5c00;font-weight:bold">{</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">onSubscribe</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Subscription</span> <span style="color:#000">s</span><span style="color:#ce5c00;font-weight:bold">);</span> <span style="color:#a40000">➊</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">onNext</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">T</span> <span style="color:#000">t</span><span style="color:#ce5c00;font-weight:bold">);</span> <span style="color:#a40000">➋</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">onError</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Throwable</span> <span style="color:#000">t</span><span style="color:#ce5c00;font-weight:bold">);</span> 
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">onComplete</span><span style="color:#ce5c00;font-weight:bold">();</span> <span style="color:#a40000">➍</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><p>➊ 订阅时被调用
➋ 每一个元素接受时被触发一次
➌ 当在触发错误的时候被调用
➍ 在接受完最后一个元素最终完成被调用</p>
<p>Subscriber 的定义可以看出来，Publisher 是主要的行为对象，用来描述我们最终的执行逻辑。</p>
<blockquote>
<p>行为是由Subscriber触发的，这是一种Pull模型，如果是Publisher触发，则为Push模型。</p>
</blockquote>
<h4 id="subscription-桥接者">Subscription 桥接者</h4>
<p>在最基础的 观察者模式 中，我们只是需要 Subscriber 观察者 Publisher 发布者，而在 PRR 中增加了一个 Subscription 作为 Subscriber Publisher 的桥接者。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">interface</span> <span style="color:#000">Subscription</span> <span style="color:#ce5c00;font-weight:bold">{</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">request</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">long</span> <span style="color:#000">n</span><span style="color:#ce5c00;font-weight:bold">);</span> <span style="color:#a40000">➊</span>
    <span style="color:#204a87;font-weight:bold">public</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">cancel</span><span style="color:#ce5c00;font-weight:bold">();</span> <span style="color:#a40000">➋</span>
<span style="color:#ce5c00;font-weight:bold">}</span>
</code></pre></div><p>➊ 获取 N 个元素往下传递
➋ 取消执行</p>
<p>为什么需要这个对象，笔者觉得是一是为了解耦合，第二在 Reference 中有提到 Backpressure 也就是下游可以保护自己不受上游大流量冲击，这个在 Stream 编程中是无法做到的，想要做到这个，就需要可以控制流速，那秘密看起来也就是在 request(long n) 中。</p>
<blockquote>
<p>中间层，主要用于解耦和流控。</p>
</blockquote>
<h3 id="23-实现原理概括">2.3 实现原理概括</h3>
<h3 id="1-命令式编程">1. 命令式编程</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_2.png" alt=""></p>
<h3 id="2-声明式编程">2. 声明式编程</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_3.png" alt=""></p>
<p>常用的、简单的数据流处理链路</p>
<p>Netty</p>
<h3 id="3-函数式编程-stream">3. 函数式编程 Stream</h3>
<blockquote>
<p>去除中间过程，横向改为纵向处理</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_4.png" alt=""></p>
<h5 id="1-声明阶段">1. 声明阶段</h5>
<p>将Op组装成Pipeline</p>
<h5 id="2-组装订阅链">2. 组装订阅链</h5>
<p>生成Sink链</p>
<p>优化：</p>
<ul>
<li>中间操作合并</li>
<li>终结操作收集数据</li>
</ul>
<h5 id="3-执行阶段">3. 执行阶段</h5>
<p>执行Sink方法</p>
<blockquote>
<p>最核心的就是类为AbstractPipeline，ReferencePipeline和Sink接口.AbstractPipeline抽象类是整个Stream中流水线的高度抽象了源头sourceStage，上游previousStage，下游nextStage，定义evaluate结束方法，而ReferencePipeline则是抽象了过滤,转换,聚合,归约等功能，每一个功能的添加实际上可以理解为卷心菜，菜心就是源头，每一次加入一个功能就相当于重新长出一片叶子包住了菜心，最后一个功能集成完毕之后整颗卷心菜就长大了。而Sink接口呢负责把整个流水线串起来，然后在执行聚合,归约时候调AbstractPipeline抽象类的evaluate结束方法，根据是否是并行执行，调用不同的结束逻辑，如果不是并行方法则执行terminalOp.evaluateSequential否则就执行terminalOp.evaluateParallel，非并行执行模式下则是执行的是AbstractPipeline抽象类的wrapAndCopyInto方法去调用copyInto，调用前会先执行一下wrapSink，用于剥开这个我们在流水线上产生的卷心菜。从下游向上游去遍历AbstractPipeline，然后包装到Sink，然后在copyInto方法内部迭代执行对应的方法。最后完成调用</p>
</blockquote>
<h4 id="4-反应式编程-reactor">4. 反应式编程 Reactor</h4>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_5.png" alt=""></p>
<p>反应式编程模型在执行中主要有5条链路:</p>
<h5 id="1-声明流程">1. 声明流程</h5>
<p>组装reactor执行链路，绑定上下游节点，在 subscribe() 之前，我们什么都没做，只是在不断的包裹 Publisher 将作为原始的 Publisher 一层又一层的返回回来。</p>
<p>生成Publisher</p>
<h5 id="2-组装订阅链-1">2. 组装订阅链</h5>
<p><code>subscribe()</code></p>
<p>生成Subscriber</p>
<blockquote>
<p>内存数据发送很简单，就是循环发送。而对于像数据库、RPC 这样的场景，则会触发请求的发送。</p>
</blockquote>
<blockquote>
<p>Publisher 接口中的 subscribe 方法语义上有些奇特，它表示的不是订阅关系，而是被订阅关系。即 aPublisher.subscribe(aSubscriber) 表示的是 aPublisher 被 aSubscriber 订阅。</p>
</blockquote>
<blockquote>
<p>对于中间过程的 Mono/Flux，subscribe 阶段是订阅上一个 Mono/Flux；而对于源 Mono/Flux，则是要执行 Subscriber.onSubscribe(Subscription s) 方法。</p>
</blockquote>
<h5 id="3-通知执行前初始化--生成许可">3. 通知：执行前初始化 + 生成许可</h5>
<p><code>onSubscribe()</code></p>
<p>生成Subscription，并将Subscriber作为成员参数传入</p>
<h5 id="4-背压流程">4. 背压流程</h5>
<p><code>request(n)</code></p>
<p>基于Subscription实现request(n)机制</p>
<h5 id="5-执行流程">5. 执行流程</h5>
<p><code>doNext()</code>/&hellip;.</p>
<p>基于Subscription中的Subscriber实现执行机制</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_6.png" alt=""></p>
<h2 id="三reactor源码分析">三、Reactor源码分析</h2>
<h3 id="31-reactor-core工作原理">3.1 Reactor-core工作原理</h3>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_7.png" alt=""></p>
<h3 id="32-实现细节">3.2 实现细节</h3>
<ol>
<li>声明阶段: 当我们每进行一次 Operator 操作 （也就 map filter flatmap），就会将原有的 FluxPublisher 包裹成一个新的 FluxPublisher</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_8.png" alt=""></p>
<p>最后生成的对象是这样的</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_9.png" alt=""></p>
<ol start="2">
<li>subscribe阶段: 当我们最终进行 subscribe 操作的时候，就会从最外层的 Publisher 一层一层的处理，从这层将 Subscriber 变化成需要的 Subscriber 直到最外层的 Publisher</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_10.png" alt=""></p>
<p>最后生成的对象是这样的</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_11.png" alt=""></p>
<ol start="3">
<li>onSubscribe阶段: 在最外层的 Publisher 的时候调用 上一层 Subscriber 的 onSubscribe 函数，在此处将 Publisher 和 Subscriber 包裹成一个 Subscription 对象作为 onSubscribe 的入参数。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_12.png" alt=""></p>
<ol start="4">
<li>最终在 原始 Subscriber 对象调用 request() ，触发 Subscription 的 Source 获得数据作为 onNext 的参数，但是注意 Subscription 包裹的是我们封装的 Subscriber 所有的数据是从 MapSubscriber 进行一次转换再给我们的原始 Subscriber 的。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_13.png" alt=""></p>
<p>经过一顿分析，整个 PRR 是如何将操作整合起来的，我们已经有一个大致的了解，通过不断的包裹出新的 Subscriber 对象，在最终的 request() 行为中触发整个消息的处理，这个过程非常像 俄罗斯套娃，一层一层的将变化组合形变操作变成一个新的 Subscriber， 然后就和一个管道一样，一层一层的往下传递。</p>
<ol start="5">
<li>最终在 Subscription 开始了我们整个系统的数据处理</li>
</ol>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_14.png" alt=""></p>
<h3 id="33-reactor示例高级用法">3.3 Reactor示例/高级用法</h3>
<p>Reactor库提供了丰富的操作符，通过这些操作符你几乎可以搭建出能够进行任何业务需求的数据处理管道/流水线。如果将Reactor的执行步骤看做一条流水线，那么操作符就可以比作流水线中的一个工作台，负责处理流程中的元素，并传递给下游。
上述章节我们了解到Reactor的执行流程包括subscribe、onSubscribe、onRequest阶段，一个基本的操作符需要实现这些阶段的处理，比如连接上下游并往下传递，之后在onNext中实现该操作符具体的功能便可以完成一个操作。接下来我们通过学习一些操作符来了解</p>
<h3 id="publishon-切换线程">publishOn 切换线程</h3>
<p>publishOn 强制下一个操作符（很可能包括下一个的下一个…）来运行在一个不同的线程上。
<img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_15.png" alt=""></p>
<h3 id="背压控制">背压控制</h3>
<p>背压指的是当Subscriber请求的数据的访问超出它的处理能力时，Publisher限制数据发送速度的能力。</p>
<p><img src="https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/reactive/img_16.png" alt=""></p>
<p>本质上背压和TCP中的窗口限流机制比较类似，都是让消费者反馈请求数据的范围，生产者根据消费者的反馈提供一定量的数据来进行流控。</p>
<p>反馈请求数据范围的操作，可以在Subscriber每次完成数据的处理之后，让Subscriber自行反馈；也可以在Subscriber外部对Subscriber的消费情况进行监视，根据监视情况进行反馈。
背压通常在以下场景中使用：</p>
<ol>
<li>网络通信中服务端控制客户端的请求速度或发布者与订阅者不在同一个线程中，因为在同一个线程中的话，通常使用传统的逻辑就可以，不需要进行回压处理；</li>
<li>发布者发出数据的速度高于订阅者处理数据的速度，也就是处于“PUSH”状态下，如果相反，那就是“PUll”状态，不需要处理回压。
我们可以自定义subscriber，并在subscriber中使用<code>request(n)</code>来通过 subscription 向上游传递 背压请求</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#000">Flux</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">String</span><span style="color:#ce5c00;font-weight:bold">&gt;</span> <span style="color:#000">source</span> <span style="color:#ce5c00;font-weight:bold">=</span> <span style="color:#000">someStringSource</span><span style="color:#ce5c00;font-weight:bold">();</span>

<span style="color:#000">source</span><span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">map</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">String</span><span style="color:#ce5c00;font-weight:bold">::</span><span style="color:#000">toUpperCase</span><span style="color:#ce5c00;font-weight:bold">)</span>
      <span style="color:#ce5c00;font-weight:bold">.</span><span style="color:#c4a000">subscribe</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#204a87;font-weight:bold">new</span> <span style="color:#000">BaseSubscriber</span><span style="color:#ce5c00;font-weight:bold">&lt;</span><span style="color:#000">String</span><span style="color:#ce5c00;font-weight:bold">&gt;()</span> <span style="color:#ce5c00;font-weight:bold">{</span> 
          <span style="color:#5c35cc;font-weight:bold">@Override</span>
          <span style="color:#204a87;font-weight:bold">protected</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">hookOnSubscribe</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">Subscription</span> <span style="color:#000">subscription</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">{</span>
              <span style="color:#8f5902;font-style:italic">//在开始这个流的时候请求一个元素值。
</span><span style="color:#8f5902;font-style:italic"></span>              <span style="color:#000">request</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">1</span><span style="color:#ce5c00;font-weight:bold">);</span> 
          <span style="color:#ce5c00;font-weight:bold">}</span>
          <span style="color:#5c35cc;font-weight:bold">@Override</span>
          <span style="color:#204a87;font-weight:bold">protected</span> <span style="color:#204a87;font-weight:bold">void</span> <span style="color:#000">hookOnNext</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">String</span> <span style="color:#000">value</span><span style="color:#ce5c00;font-weight:bold">)</span> <span style="color:#ce5c00;font-weight:bold">{</span>
                <span style="color:#8f5902;font-style:italic">//执行onnext的时候向上游请求一个元素
</span><span style="color:#8f5902;font-style:italic"></span>              <span style="color:#000">request</span><span style="color:#ce5c00;font-weight:bold">(</span><span style="color:#000">1</span><span style="color:#ce5c00;font-weight:bold">);</span> 
          <span style="color:#ce5c00;font-weight:bold">}</span>
      <span style="color:#ce5c00;font-weight:bold">});</span>
</code></pre></div><h3 id="34-reactor流程总结">3.4 Reactor流程总结</h3>
<ol>
<li>在声明阶段，我们像 俄罗斯套娃 一样，创建一个嵌套一个的 Publisher</li>
<li>在 subscribe() 调用的时候，我们从最外围的 Publisher 根据包裹的 Operator 创建各种 Subscriber</li>
<li>Subscriber 通过 onSubscribe() 使得他们像一个链条一样关联起来，并和 最外围的 Publisher 组合成一个 Subscription</li>
<li>在最底层的 Subscriber 调用 onSubscribe 去调用 Subscription 的 request(n); 函数开始操作</li>
<li>元素就像水管中的水一样挨个 经过 Subscriber 的 onNext()，直至我们最终消费的 Subscriber</li>
</ol>
<h2 id="四反应式编程总结">四、反应式编程总结</h2>
<h3 id="41-编程理论">4.1 编程理论</h3>
<ul>
<li>命令式编程/面向对象编程 → 优缺点，适用场景</li>
<li>函数式编程 → 算子，副作用约束，函数式流编程</li>
<li>声明式编程 → 动词封装，逻辑清晰</li>
<li>反应式编程 → 异步非阻塞，事件驱动/消息驱动，背压</li>
</ul>
<h3 id="42-流式框架的设计">4.2 流式框架的设计</h3>
<ul>
<li>同步流框架设计（一线）
<ul>
<li>函数式流</li>
</ul>
</li>
<li>异步流框架设计（二线）
<ul>
<li>Netty等框架，声明编排</li>
</ul>
</li>
<li>完善的流式框架设计（三线）
<ul>
<li>Java Stream</li>
</ul>
</li>
<li>反应式流框架设计（五线）
<ul>
<li>反应式编程框架，反应式网络协议</li>
</ul>
</li>
</ul>
<h3 id="43-底层原理">4.3 底层原理</h3>
<ul>
<li>异步非阻塞IO原理
<ul>
<li>Epoll，CF</li>
</ul>
</li>
<li>网络协议
<ul>
<li>gRPC，RSocket</li>
</ul>
</li>
<li>传统阻塞IO原理
<ul>
<li>JDBC，BIO</li>
</ul>
</li>
</ul>

</div>





    
	
  

    
	
  



          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="User mailing list" aria-label="User mailing list">
    <a class="text-white" target="_blank" rel="noopener" href="https://github.com/capa-cloud" aria-label="User mailing list">
      <i class="fa fa-envelope"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" rel="noopener" href="https://github.com/capa-cloud" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        <small class="text-white">&copy; 2022 The Capa Authors All Rights Reserved</small>
        <small class="ml-1"><a href="https://policies.google.com/privacy" target="_blank" rel="noopener">隐私政策</a></small>
	
		<p class="mt-2"><a href="/capa.io/about/">About Capa</a></p>
	
      </div>
    </div>
  </div>
</footer>


    </div>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" integrity="sha384-+YQ4JLhjyBLPDQt//I+STsc9iw4uQqACwlvpslubQzn4u2UU2UFM80nGisd026JF" crossorigin="anonymous"></script>





<script src='/capa.io/js/tabpane-persist.js'></script>




 












<script src="/capa.io/js/main.min.ee950676387eab97235d899be7f8fdf5f1cd0751e479d20dd3f3bcb825c7fd46.js" integrity="sha256-7pUGdjh&#43;q5cjXYmb5/j99fHNB1HkedIN0/O8uCXH/UY=" crossorigin="anonymous"></script>




  </body>
</html>
