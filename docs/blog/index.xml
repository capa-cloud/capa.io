<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Capa – Capa Blog</title>
    <link>https://reactivegroup.github.io/capa.io/blog/</link>
    <description>Recent content in Capa Blog on Capa</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://reactivegroup.github.io/capa.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Blog: gRPC Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/01/21/grpc-landscape/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/01/21/grpc-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;一why-grpc&#34;&gt;一、Why gRPC?&lt;/h2&gt;
&lt;h3 id=&#34;cloud-native-interactive-landscape&#34;&gt;Cloud Native Interactive Landscape&lt;/h3&gt;
&lt;p&gt;CNCF 云原生景观全景图：https://landscape.cncf.io/?zoom=400&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/cloud-native.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;面对庞大的技术栈，有选择性的进行研究：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用上了解&lt;/li&gt;
&lt;li&gt;原理上了解&lt;/li&gt;
&lt;li&gt;设计上了解&lt;/li&gt;
&lt;li&gt;源码级了解&lt;/li&gt;
&lt;li&gt;参与贡献&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;application-layer&#34;&gt;Application layer&lt;/h3&gt;
&lt;p&gt;偏向 应用层 的技术栈：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/cloud-native-stack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;messaging&#34;&gt;messaging&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/messaging.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mesh&#34;&gt;mesh&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/mesh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;rpc&#34;&gt;rpc&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/rpc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;serverless-framework&#34;&gt;serverless framework&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/serverless.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;grpc&#34;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;云原生 应用层 技术栈，大量使用了gRPC作为网络通讯的协议/框架&lt;/p&gt;
&lt;h4 id=&#34;grpc-go&#34;&gt;gRPC-go&lt;/h4&gt;
&lt;p&gt;尤其是go-sdk，在大量sidecar模式架构中进行使用。&lt;/p&gt;
&lt;p&gt;Go语言gRPC技术栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://chai2010.gitbooks.io/advanced-go-programming-book/content/images/ch4-1-grpc-go-stack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;why-grpc&#34;&gt;Why gRPC?&lt;/h3&gt;
&lt;p&gt;鉴于 gRPC 在应用层技术栈的广泛使用和重要性，对其有源码级了解是有价值的。&lt;/p&gt;
&lt;h2 id=&#34;二grpc协议&#34;&gt;二、gRPC协议&lt;/h2&gt;
&lt;h3 id=&#34;设计原则&#34;&gt;设计原则&lt;/h3&gt;
&lt;p&gt;● 服务非对象、消息非引用 —— 促进微服务的系统间粗粒度消息交互设计理念，同时避免分布式对象的陷阱和分布式计算的谬误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;和 DCOM 及 EJB 完全相反的。只有数据，不包含逻辑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式计算谬误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络可靠；&lt;/li&gt;
&lt;li&gt;延迟为零；&lt;/li&gt;
&lt;li&gt;带宽是无限的；&lt;/li&gt;
&lt;li&gt;网络安全；&lt;/li&gt;
&lt;li&gt;拓扑不变；&lt;/li&gt;
&lt;li&gt;有一名管理员；&lt;/li&gt;
&lt;li&gt;运输成本为零；&lt;/li&gt;
&lt;li&gt;网络是同质的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 普遍并且简单 —— 该基础框架应该在任何流行的开发平台上适用，并且易于被个人在自己的平台上构建。它在CPU和内存有限的设备上也应该切实可行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;协议的设计应考虑全面的应用场景：边缘节点、serverless等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 免费并且开源 —— 所有人可免费使用基本特性。以友好的许可协议开源方式发布所有交付件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;避免具体技术锁定，应是可插拔的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;互通性&lt;/strong&gt; —— 该报文协议(Wire Protocol)必须遵循普通互联网基础框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同现有网络设施的兼容性和连通性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;over HTTP&lt;/li&gt;
&lt;li&gt;over TCP&lt;/li&gt;
&lt;li&gt;over UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 通用并且高性能 —— 该框架应该适用于绝大多数用例场景，相比针对特定用例的框架，该框架只会牺牲一点性能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要通用性，不要极端性能优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 分层的 —— 该框架的关键是必须能够独立演进。对报文格式(Wire Format)的修改不应该影响应用层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抽象的编程模型，与具体实现解耦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 负载无关的 —— 不同的服务需要使用不同的消息类型和编码，例如protocol buffers、JSON、XML和Thrift，协议上和实现上必须满足这样的诉求。类似地，对负载压缩的诉求也因应用场景和负载类型不同而不同，协议上应该支持可插拔的压缩机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Payload agnostic，RPC 框架不应该规定用的是什么 payload 格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;流&lt;/strong&gt; —— 存储系统依赖于流和流控来传递大数据集。像语音转文本或股票代码等其它服务，依靠流表达时间相关的消息序列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在某种程度上，可以将其理解为类似消息系统的消息队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.toutiao.io/c/df910edf0aca9dd3ba8387f2e767411d&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;● 阻塞式和非阻塞式 —— 支持异步和同步处理在客户端和服务端间交互的消息序列。这是在某些平台上缩放和处理流的关键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户态线程阻塞模型性能较差，应使用NIO编程模型，支持异步非阻塞式的交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;取消和超时&lt;/strong&gt; —— 有的操作可能会用时很长，客户端运行正常时，可以通过取消操作让服务端回收资源。当任务因果链被追踪时，取消可以级联。客户端可能会被告知调用超时，此时服务就可以根据客户端的需求来调整自己的行为。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持重置功能(RST_STREAM 帧)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;Lameducking&lt;/strong&gt; —— 服务端必须支持优雅关闭，优雅关闭时拒绝新请求，但继续处理正在运行中的请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优先级设计(Http2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对流ID&lt;/li&gt;
&lt;li&gt;流级联设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;流控&lt;/strong&gt; —— 在客户端和服务端之间，计算能力和网络容量往往是不平衡的。流控可以更好的缓冲管理，以及保护系统免受来自异常活跃对端的拒绝服务(DOS)攻击。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;维护缓冲区：窗口/背压/租约&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;基于HTTP2缓冲区的流控机制
基于应用层语义的流控&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 可插拔的 —— 数据传输协议(Wire Protocol)只是功能完备API基础框架的一部分。大型分布式系统需要安全、健康检查、负载均衡和故障恢复、监控、跟踪、日志等。实现上应该提供扩展点，以允许插入这些特性和默认实现。&lt;/p&gt;
&lt;p&gt;● API扩展 —— 可能的话，在服务间协作的扩展应该最好使用接口扩展，而不是协议扩展。这种类型的扩展可以包括健康检查、服务内省、负载监测和负载均衡分配。&lt;/p&gt;
&lt;p&gt;● 元数据交换 —— 常见的横切关注点，如认证或跟踪，依赖数据交换，但这不是服务公共接口中的一部分。部署依赖于他们将这些特性以不同速度演进到服务暴露的个别API的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metadata与payload分离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 标准化状态码 —— 客户端通常以有限的方式响应API调用返回的错误。应该限制状态代码名字空间，使得这些错误处理决定更清晰。如果需要更丰富的特定域的状态，可以使用元数据交换机制来提供。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;● &lt;strong&gt;对端平等&lt;/strong&gt; —— 人机交互强调 客户端-&amp;gt;服务端 模型，机器之间交互任意一端都可作为客户端/服务端&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;长链接&lt;/strong&gt; —— 为服务端推送和双向流交互提供基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完善的应用层状态码命名空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;http2&#34;&gt;HTTP2&lt;/h3&gt;
&lt;h3 id=&#34;交互分析&#34;&gt;交互分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H0HPgv9.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;li&gt;SETTINGS&lt;/li&gt;
&lt;li&gt;HEADERS&lt;/li&gt;
&lt;li&gt;DATA&lt;/li&gt;
&lt;li&gt;SETTINGS&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE&lt;/li&gt;
&lt;li&gt;PING&lt;/li&gt;
&lt;li&gt;HEADERS&lt;/li&gt;
&lt;li&gt;DATA&lt;/li&gt;
&lt;li&gt;HEADERS&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE&lt;/li&gt;
&lt;li&gt;PING&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;主链路&#34;&gt;主链路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;li&gt;Settings&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;流链路&#34;&gt;流链路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Settings&lt;/li&gt;
&lt;li&gt;Headers&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;Window_update&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;控制链路&#34;&gt;控制链路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Window_update&lt;/li&gt;
&lt;li&gt;Ping&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FrA8EW4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在建立连接之前，客户端/服务端都会发送连接前言（Magic+SETTINGS），确立协议和配置项。&lt;/li&gt;
&lt;li&gt;在传输数据时，是会涉及滑动窗口（WINDOW_UPDATE）等流控策略的。&lt;/li&gt;
&lt;li&gt;传播 gRPC 附加信息时，是基于 HEADERS 帧进行传播和设置；而具体的请求/响应数据是存储的 DATA 帧中的。&lt;/li&gt;
&lt;li&gt;请求/响应结果会分为 HTTP 和 gRPC 状态响应两种类型。&lt;/li&gt;
&lt;li&gt;客户端发起 PING，服务端就会回应 PONG，反之亦可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;grpc-1&#34;&gt;grpc&lt;/h3&gt;
&lt;h4 id=&#34;语义概念&#34;&gt;语义概念&lt;/h4&gt;
&lt;p&gt;gRPC 引入了三个新概念：通道、远程过程调用(RPC) 和消息。三者之间的关系很简单：每个通道可能有很多 RPC，而每个 RPC 可能有很多消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://grpc.io/img/channels_mapping_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://grpc.io/img/grpc_on_http2_mapping_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通道是 gRPC 中的一个关键概念。HTTP/2 中的流支持在单个连接上进行多个并发会话；通道通过在多个并发连接上启用多个流来扩展这个概念。&lt;/p&gt;
&lt;p&gt;通道代表到端点的虚拟连接，实际上可能由许多 HTTP/2 连接支持。RPC 与连接相关联。RPC 实际上是普通的 HTTP/2 流。消息与 RPC 相关联并作为 HTTP/2 数据帧发送。更具体地说，消息是在数据帧之上分层的。一个数据帧可能有很多 gRPC 消息，或者如果一个 gRPC 消息非常大它可能跨越多个数据帧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC 对 16kb 的数据帧使用 HTTP/2 默认的最大大小。超过 16kb 的消息可能跨越多个数据帧，而低于该大小的消息可能与一些其他消息共享一个数据帧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;并非与http2强绑定&#34;&gt;并非与HTTP2强绑定？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Channel
&lt;ul&gt;
&lt;li&gt;Conns&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RPC
&lt;ul&gt;
&lt;li&gt;Conn&lt;/li&gt;
&lt;li&gt;Stream&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Message
&lt;ul&gt;
&lt;li&gt;Frame m:n&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三grpc框架&#34;&gt;三、gRPC框架&lt;/h2&gt;
&lt;h3 id=&#34;主链路-1&#34;&gt;主链路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;启动net server
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Stub
&lt;ul&gt;
&lt;li&gt;Contact
&lt;ul&gt;
&lt;li&gt;proto&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Channel
&lt;ul&gt;
&lt;li&gt;生命周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;业务executor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Channel
&lt;ul&gt;
&lt;li&gt;创建ClientCall(RPC)&lt;/li&gt;
&lt;li&gt;将ClientCall转化成realCall(H2 Conn)&lt;/li&gt;
&lt;li&gt;将realCall转化成realStream (H2 Stream)&lt;/li&gt;
&lt;li&gt;执行realStream&lt;/li&gt;
&lt;li&gt;获取Response&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;H2 Conn:&lt;/p&gt;
&lt;p&gt;startCall&lt;/p&gt;
&lt;p&gt;call.sendMessage&lt;/p&gt;
&lt;p&gt;call.halfMessage&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903984524705800&#34;&gt;https://juejin.cn/post/6844903984524705800&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/docs/what-is-grpc/core-concepts/&#34;&gt;https://grpc.io/docs/what-is-grpc/core-concepts/&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/blog/grpc-on-http2/&#34;&gt;https://grpc.io/blog/grpc-on-http2/&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/blog/yikyak/&#34;&gt;https://grpc.io/blog/yikyak/&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/blog/grpc-load-balancing/&#34;&gt;https://grpc.io/blog/grpc-load-balancing/&lt;/a&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000019608421&#34;&gt;https://segmentfault.com/a/1190000019608421&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Capa: Mecha SDK of Cloud Application Api</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/01/18/capa-mecha-sdk-of-cloud-application-api/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/01/18/capa-mecha-sdk-of-cloud-application-api/</guid>
      <description>
        
        
        &lt;h1 id=&#34;capacloud-application-api架起混合云应用开发的桥梁&#34;&gt;Capa(Cloud-Application-API)：架起混合云应用开发的桥梁&lt;/h1&gt;
&lt;p&gt;&amp;ldquo;让代码实现&amp;quot;一次编写，随处运行&amp;rdquo;。 借助Capa体系，使你的Java应用在改动量较小的情况下，拥有跨云、混合云运行的能力。&amp;quot;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者简介： 
KevinTen，携程后端开发工程师，关注Reactive、RPC和云原生领域，对Mecha混合云中间件有深度实践经验。 
Capa官方GitHub地址:&lt;a href=&#34;https://github.com/reactivegroup/capa&#34;&gt;https://github.com/reactivegroup/capa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在过去微服务的发展历程中，各大厂商基于SDK模式已经有相对完善的中间件体系。但在业务全球化、混合多云架构场景下，业务应用对基础设施的标准化和解耦、可迁移性以及拥抱开源成为新的诉求。
以当前的业界实践及趋势来看，ServiceMesh 这种 Sidecar 架构与体系是满足上述诉求的最佳实践。&lt;/p&gt;
&lt;p&gt;ServiceMesh 在微服务领域已经非常流行，越来越多的公司开始在内部落地，ServiceMesh 带来的业务解耦，平滑升级等优势大大提高了中间件的迭代效率。&lt;/p&gt;
&lt;p&gt;不过 ServiceMesh 只解决了服务间通讯的需求，而现实中的分布式应用存在更多的需求。而效仿 ServiceMesh 将应用需要的其他分布式能力外移到各种 Sidecar Runtime，这逐渐演变成了一个趋势。&lt;/p&gt;
&lt;p&gt;本文主要对 ServiceMesh 进行回顾总结，并分享业界基于 ServiceMesh 这种 Sidecar 模式解决混合云应用开发的解决方案，最后是关于混合云应用开发模式的探讨。&lt;/p&gt;
&lt;h2 id=&#34;一service-mesh-回顾与总结&#34;&gt;一、Service Mesh 回顾与总结&lt;/h2&gt;
&lt;h3 id=&#34;aservice-mesh-的初衷&#34;&gt;A、Service Mesh 的初衷&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*p8tGTbpLRegAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
在微服务架构下，基础架构团队一般会为应用提供一个封装了各种服务治理能力的 SDK，这种做法虽然保障了应用的正常运行，但缺点也非常明显，每次基础架构团队迭代一个新功能都需要业务方参与升级才能使用，尤其是 bugfix 版本，往往需要强推业务方升级，这里面的痛苦程度每一个基础架构团队成员都深有体会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;伴随着升级的困难，随之而来的就是应用使用的 SDK 版本差别非常大，生产环境同时跑着各种版本的 SDK，这种现象又会让新功能的迭代必须考虑各种兼容，就好像带着枷锁前进一般，这样随着不断迭代，会让代码维护非常困难，有些祖传逻辑更是一不小心就会掉坑里。&lt;/p&gt;
&lt;p&gt;同时这种“重”SDK 的开发模式，导致异构语言的治理能力非常薄弱，如果想为各种编程语言都提供一个功能完整且能持续迭代的 SDK 其中的成本可想而知。&lt;/p&gt;
&lt;p&gt;18 年的时候，Service Mesh 在国内持续火爆，这种架构理念旨在把服务治理能力跟业务解耦，让两者通过进程级别的通信方式进行交互。在这种架构模式下，服务治理能力从应用中剥离，运行在独立的进程中，迭代升级跟业务进程无关，这就可以让各种服务治理能力快速迭代，并且由于升级成本低，因此每个版本都可以全部升级，解决了历史包袱问题，同时 SDK 变“轻”直接降低了异构语言的治理门槛，再也不用为需要给各个语言开发相同服务治理能力的 SDK 头疼了。&lt;/p&gt;
&lt;h3 id=&#34;bservice-mesh-落地现状&#34;&gt;B、Service Mesh 落地现状&lt;/h3&gt;
&lt;h4 id=&#34;istio&#34;&gt;Istio&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/xokpWwTItyEW2YN4Iklmww&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;探索阶段：2017 年 - 2018 年&lt;/li&gt;
&lt;li&gt;早期采用者阶段：2019 年 - 2020 年&lt;/li&gt;
&lt;li&gt;大规模落地及生态发展阶段：2021 年至今&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果根据 “跨越鸿沟” 理论，服务网格已经跨越了 “鸿沟”，处于 “早期大众” 和 “晚期大众” 阶段之间。根据《Istio 大咖说》 观众中的反馈来看，用户已不再盲从于新技术，开始辩证的考虑 是否真的需要引入服务网格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/service-mesh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mson&#34;&gt;Mson&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*rRG_TYlHMqYAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
蚂蚁很快意识到了 Service Mesh 的价值，全力投入到这个方向，用 Go 语言开发了 MOSN 这样可以对标 envoy 的优秀数据面，全权负责服务路由，负载均衡，熔断限流等能力的建设，大大加快了公司内部落地 Service Mesh 的进度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在 MOSN 在蚂蚁内部已经覆盖了数千个应用、数十万容器，新创建的应用默认接入 MOSN，形成闭环。而且在大家最关心的资源占用、性能损耗方面 MOSN 也交出了一份让人满意的答卷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;RT 小于 0.2ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 占用增加 0%~2%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存消耗增长小于 15M&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Service Mesh 降低了异构语言的服务治理门槛，NodeJS、C++等异构技术栈也在持续接入到 MOSN 中。&lt;/p&gt;
&lt;p&gt;在看到 RPC 能力 Mesh 化带来的巨大收益之后，蚂蚁内部还把 MQ，Cache，Config 等中间件能力都进行了 Mesh 化改造，下沉到 MOSN，提高了中间件产品整体的迭代效率。&lt;/p&gt;
&lt;h3 id=&#34;c新的挑战&#34;&gt;C、新的挑战&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Mesh化是云原生落地的关键步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最下方是云，以kubernetes为核心，关于这一点社区基本已经达成共识：kubernetes 就是云原生下的操作系统&lt;/li&gt;
&lt;li&gt;在kubernetes之上，是Mesh层。不仅仅有我们熟悉的 ServiceMesh，还有诸如Database Mesh和Message Mesh等类似的其他 Mesh 产品形态，这些Mesh组成了一个标准化的通信层。&lt;/li&gt;
&lt;li&gt;运行在各种 Mesh 的应用，不管是微服务形态，还是传统非微服务形态，都可以借助Mesh的帮助实现应用轻量化。非业务逻辑的各种功能被剥离到Mesh中后，应用得以“瘦身减负”。&lt;/li&gt;
&lt;li&gt;瘦身之后的应用，其内容主要是业务逻辑实现。这样的工作负载形式，更适合 serverless 的要求，为接下来转型 serverless 做好准备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/images/ant-more-mesh_hu56c375bdd66e5b8ec5c7446e085ec97c_227360_1200x1200_fit_lanczos_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;x-mesh&#34;&gt;X Mesh&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://skyao.io/talk/201910-ant-finance-service-mesh-deep-practice/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*nKxcTKLp4EoAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
一个现代分布式应用，往往会同时依赖 RPC、Cache、MQ、Config 等各种分布式能力来完成业务逻辑的处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当初看到 RPC 下沉的红利以后，其他各种能力也都快速下沉。&lt;/p&gt;
&lt;p&gt;初期，大家都会以自己最熟悉的方式来开发，这就导致没有统一的规划管理，如上图所示，应用依赖了各种基础设施的 SDK，而每种 SDK 又以自己特有的方式跟 MOSN 进行交互，使用的往往都是由原生基础设施提供的私有协议，这直接导致了复杂的中间件能力虽然下沉，但应用本质上还是被绑定到了基础设施。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中间件抽象不足&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如想把缓存从 Redis 迁移到 Memcache 的话，仍旧需要业务方升级 SDK，这种问题在应用上云的大趋势下表现的更为突出。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;应用跟基础设施强绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;试想一下，如果一个应用要部署在云上，由于该应用依赖了各种基础设施，势必要先把整个基础设施搬到云上才能让应用顺利部署，这其中的成本可想而知。
因此如何让应用跟基础设施解绑，使其具备可移植能力，能够无感知跨平台部署是我们面临的第一个问题。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;异构语言接入成本高&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*oIdQQZmgtyUAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
事实证明 Service Mesh 确实降低了异构语言的接入门槛，但在越来越多的基础能力下沉到 MOSN 以后，我们逐渐意识到为了让应用跟 MOSN 交互，各种 SDK 里都需要对通信协议，序列化协议进行开发，如果再加上需要对各种异构语言都提供相同的功能，那维护难度就会成倍上涨，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Service Mesh 让重 SDK 成为了历史，但对于现在各种编程语言百花齐放、各种应用又强依赖基础设施的场景来说，我们发现现有的 SDK 还不够薄，异构语言接入的门槛还不够低，如何进一步降低异构语言的接入门槛是我们面临的第二个问题。&lt;/p&gt;
&lt;h2 id=&#34;二multi-runtime-理论概述&#34;&gt;二、Multi Runtime 理论概述&lt;/h2&gt;
&lt;h3 id=&#34;a什么是-runtime&#34;&gt;A、什么是 Runtime?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*hQT-Spc5rI4AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
20 年初的时候，Bilgin lbryam 发表了一篇名为
Multi-Runtime Microservices Architecture
的文章，里面对微服务架构下一阶段的形态进行了讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上图所示，作者把分布式服务的需求进行了抽象，总共分为了四大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生命周期（Lifecycle）
主要指应用的编译、打包、部署等事情，在云原生的大趋势下基本被 docker、kubernetes 承包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络（Networking）
可靠的网络是微服务之间进行通信的基本保障，Service Mesh 正是在这方面做了尝试，目前 MOSN、envoy 等流行的数据面的稳定性、实用性都已经得到了充分验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态（State）
分布式系统需要的服务编排，工作流，分布式单例，调度，幂等性，有状态的错误恢复，缓存等操作都可以统一归为底层的状态管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定（Binding）
在分布式系统中，不仅需要跟其他系统通信，还需要集成各种外部系统，因此对于协议转换，多种交互模型、错误恢复流程等功能也都有强依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;明确了需求以后，借鉴了 Service Mesh 的思路，作者对分布式服务的架构演进进行了如下总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*rwS2Q5yMp_sAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
第一阶段就是把各种基础设施能力从应用中剥离解耦，通通变成独立 sidecar 模型伴随着应用一起运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二阶段是把各种 sidecar 提供的能力统一抽象成若干个 Runtime，这样应用从面向基础组件开发就演变成了面向各种分布式能力开发，彻底屏蔽掉了底层实现细节，而且由于是面向能力，除了调用提供各种能力的 API 之外，应用再也不需要依赖各种各样基础设施提供的 SDK 了。&lt;/p&gt;
&lt;p&gt;作者的思路跟我们希望解决的问题一致，我们决定使用 Runtime 的理念来解决 Service Mesh 发展到现在所遇到的新问题。&lt;/p&gt;
&lt;h3 id=&#34;bservice-mesh-vs-runtime&#34;&gt;B、Service Mesh vs Runtime&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*srPVSYTEHc4AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
为了让大家对 Runtime 有一个更加清晰的认识，上图针对 Service Mesh 跟 Runtime 两种理念的定位、交互方式、通信协议以及能力丰富度进行了总结，可以看到相比 Service Mesh 而言，Runtime 提供了语义明确、能力丰富的 API，可以让应用跟它的交互变得更加简单直接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/cloud-native-stack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三multi-runtime-落地实践&#34;&gt;三、Multi Runtime 落地实践&lt;/h2&gt;
&lt;h3 id=&#34;adapr&#34;&gt;A、dapr&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/93/93ccecd9a241b5c6921b988b18f0362e.png&#34; alt=&#34;&#34;&gt;
dapr 是社区中一款知名的 Runtime 实现产品，活跃度也比较高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/dapr-archi.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供了多种分布式能力，API 定义清晰，基本能满足一般的使用场景。&lt;/li&gt;
&lt;li&gt;针对各种能力都提供了不同的实现组件，基本涵盖了常用的中间件产品，用户可以根据需要自由选择。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;控制平面&#34;&gt;控制平面&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/images/dapr-control-plane_hu32ec8c339282b281cdff3c71662e3695_1613641_1200x1200_fit_lanczos_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;和service-mesh共存&#34;&gt;和Service Mesh共存&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://docs.dapr.io/concepts/service-mesh/#using-dapr-with-a-service-mesh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://docs.dapr.io/images/service-mesh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当考虑如何在已使用Service Mesh公司内部落地 dapr 时，提出了两种方案，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;替换：废弃掉现在的Istio，用 dapr 进行替换，这种方案存在两个问题：&lt;/p&gt;
&lt;p&gt;a.  dapr 虽然提供了很多分布式能力，但目前并不具备 Service Mesh 包含的丰富的服务治理能力。&lt;/p&gt;
&lt;p&gt;b.  Istio 已经大规模落地，并且经过了考验，直接用 dapr 来替换 Istio 稳定性有待验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共存：新增一个 dapr 容器，跟 Istio 以两个 sidecar 的模式进行部署。这种方案同样存在两个问题：&lt;/p&gt;
&lt;p&gt;a.  引入一个新的 sidecar，我们就需要考虑它配套的升级、监控、注入等等事情，运维成本飙升。&lt;/p&gt;
&lt;p&gt;b.  多维护一个容器意味着多了一层挂掉的风险，这会降低现在的系统可用性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;blayotto&#34;&gt;B、Layotto&lt;/h3&gt;
&lt;p&gt;同样的，如果你目前正在使用 envoy 作为数据面，也会面临上述问题。&lt;/p&gt;
&lt;p&gt;因此我们希望把 Runtime 跟 Service Mesh 两者结合起来，通过一个完整的 sidecar 进行部署，在保证稳定性、运维成本不变的前提下，最大程度复用现有的各种 Mesh 能力。此外我们还希望这部分 Runtime 能力除了跟 Istio 结合起来之外，未来也可以跟 envoy 结合起来，解决更多场景中的问题，Layotto 就是在这样的背景下诞生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*sdGoSYB_XFUAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
如上图所示，Layotto 是构建在 MOSN 之上，在下层对接了各种基础设施，向上层应用提供了统一的，具有各种各样分布式能力的标准 API。对于接入 Layotto 的应用来说，开发者不再需要关心底层各种组件的实现差异，只需要关注应用需要什么样的能力，然后调用对应能力的 API 即可，这样可以彻底跟底层基础设施解绑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对应用来说，交互分为两块，一个是作为 gRPC Client 调用 Layotto 的标准 API，一个是作为 gRPC Server 来实现 Layotto 的回调，得利于gRPC 优秀的跨语言支持能力，应用不再需要关心通信、序列化等细节问题，进一步降低了异构技术栈的使用门槛。&lt;/p&gt;
&lt;p&gt;除了面向应用，Layotto 也向运维平台提供了统一的接口，这些接口可以把应用跟 sidecar 的运行状态反馈给运维平台，方便 SRE 同学及时了解应用的运行状态并针对不同状态做出不同的举措，该功能考虑到跟 k8s 等已有的平台集成，因此我们提供了 HTTP 协议的访问方式。&lt;/p&gt;
&lt;p&gt;除了 Layotto 本身设计以外，项目还涉及两块标准化建设，首先想要制定一套语义明确，适用场景广泛的 API 并不是一件容易的事情，为此我们跟阿里、 dapr 社区进行了合作，希望能够推进 Runtime API 标准化的建设，其次对于 dapr 社区已经实现的各种能力的 Components 来说，我们的原则是优先复用、其次开发，尽量不把精力浪费在已有的组件上面，重复造轮子。&lt;/p&gt;
&lt;p&gt;最后 Layotto 目前虽然是构建在 MOSN 之上，未来我们希望 Layotto 可以跑在 envoy 上，这样只要应用接入了 Service Mesh，无论数据面使用的是 MOSN 还是 envoy，都可以在上面增加 Runtime能力。&lt;/p&gt;
&lt;h3 id=&#34;ccapa&#34;&gt;C、Capa&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;github: &lt;a href=&#34;https://github.com/reactivegroup/capa&#34;&gt;https://github.com/reactivegroup/capa&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Capa项目基于Mecha架构的设计理念，使用 富SDK模式 提供Multi-Runtime的标准API。&lt;/p&gt;
&lt;p&gt;您可以简单的将Capa项目理解为 Dapr / Layotto 等Sidecar模式项目的SDK实现版本。&lt;/p&gt;
&lt;h4 id=&#34;sidecar-or-sdk&#34;&gt;Sidecar or SDK&lt;/h4&gt;
&lt;p&gt;基于Mecha架构理念的Multi-Runtime，以Sidecar的方式提供标准API的功能，看起来似乎是最合理的选择。&lt;/p&gt;
&lt;p&gt;那为什么不直接使用Dapr/Layotto等项目，而是选择开发 富SDK模式 的Capa项目呢。&lt;/p&gt;
&lt;p&gt;概括：以Dapr为代表的Sidecar架构是未来，但现有的很多企业和系统很难一步到位的升级到Sidecar架构，富SDK架构将会长期的存在下去。&lt;/p&gt;
&lt;p&gt;引申：面对庞大的Java系统体系，Capa项目将使用富SDK模型支持Java系统向Mecha架构过渡。在Dapr等项目成熟后，也可以无缝衔接到Sidecar架构。&lt;/p&gt;
&lt;h4 id=&#34;能力水平模型&#34;&gt;能力水平模型&lt;/h4&gt;
&lt;p&gt;选用sidecar来进行中间件支持，存在以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在过去我们积累了丰富的Java SDK，全盘舍弃意味着巨大的损失。&lt;/li&gt;
&lt;li&gt;社区还比较年轻，短时间内用golang重写所有SDK逻辑不太现实。&lt;/li&gt;
&lt;li&gt;社区对公有云功能支持比较好，私有云主要依赖SDK模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/feature-support.png&#34; alt=&#34;img.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;capa设计&#34;&gt;Capa设计&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://github.com/dapr/dapr/issues/3261&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计思路：标准API + 可拔插可替换的SDK组件 模式&lt;/p&gt;
&lt;p&gt;在不同的分布式中间件领域，Capa提供与具体中间件API无关的统一的标准编程API。 所以应用程序在使用Capa编程时不需要依赖任何具体的中间件API，只需要依赖Capa的标准编程API即可。&lt;/p&gt;
&lt;p&gt;在部署到不同的目标环境时，Capa将会装载标准API的不同实现类到应用程序中。当调用统一的编程API时，底层运行时会适配到不同的具体中间件SDK实现。&lt;/p&gt;
&lt;p&gt;中间件团队需要针对不同目标环境，开发标准API在目标环境下的实现类即可；而应用代码可以拥有&amp;quot;一次编写，随处运行&amp;quot;的开发体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/22876610/120766251-9ef56200-c54c-11eb-9fc2-15b17937b4bb.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dfemas--other--&#34;&gt;D、Femas / Other / &amp;hellip;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://www.yuque.com/docs/share/5221c27a-9d0c-44c7-8ef2-0956d3b09a32?#&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/12961124/1632385886671-69b482d2-eef9-498d-a036-021e3810e6ee.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;e移植性&#34;&gt;E、移植性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*2DrSQJ6GL8cAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
如上图所示，一旦完成 Runtime API 的标准化建设，接入 Mecha 的应用天然具备了可移植性，应用不需要任何改造就可以在私有云以及各种公有云上部署，并且由于使用的是标准 API，应用也可以无需任何改造就在 Layotto / dapr / Capa 之间自由切换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;未来迁移&#34;&gt;未来迁移&lt;/h4&gt;
&lt;p&gt;推动API的标准化建设：使各大Mecha体系保持API层的统一，保留未来互相迁移的可能。&lt;/p&gt;
&lt;p&gt;从未来几年来看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在较小的私有云，会长期支持SDK模式。&lt;/li&gt;
&lt;li&gt;在较大的私有云，框架团队有能力完成大规模sidecar化改造，会从SDK模式迁移到Sidecar模式。&lt;/li&gt;
&lt;li&gt;在公有云，目前可以选用SDK模式/Sidecar模式，SDK模式更有利于二次定制；&lt;/li&gt;
&lt;li&gt;随着社区在公有云能力的发展，以及云厂商的支持，未来可全部切换到sidecar模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四api设计原则&#34;&gt;四、API设计原则&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://www.infoq.cn/article/wjkNGoGaaHyKs7xIyTSB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;a功能集选择&#34;&gt;A、功能集选择&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/api-design.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;组件提供的能力不平齐&#34;&gt;组件提供的能力不平齐&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/29/298af0137732cd1fb526bd46229a71fc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;解决思路一runtime-弥补组件缺失能力sidecar&#34;&gt;解决思路一：Runtime 弥补组件缺失能力（sidecar）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/ca/caa5f9fc42715d24967cbeed433bd870.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;解决思路二component-弥补组件缺失能力&#34;&gt;解决思路二：Component 弥补组件缺失能力&lt;/h4&gt;
&lt;p&gt;Capa：&lt;/p&gt;
&lt;p&gt;通过集成Plugin，弥补AWS公有云SDK组件能力，对齐私有云组件能力。
通过Plugin自定义加载机制，切换不同的能力实现。&lt;/p&gt;
&lt;h4 id=&#34;解决思路三无法弥补但可以模糊处理&#34;&gt;解决思路三：无法弥补，但可以模糊处理&lt;/h4&gt;
&lt;p&gt;能力分层模型。&lt;/p&gt;
&lt;h4 id=&#34;解决思路四无法弥补又不能模糊处理&#34;&gt;解决思路四：无法弥补又不能模糊处理&lt;/h4&gt;
&lt;p&gt;高危，按条件选用&lt;/p&gt;
&lt;h3 id=&#34;b分层模型&#34;&gt;B、分层模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/2a/2a92f5f1dd7d8dae44df981e3afa5368.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;c拓展字段&#34;&gt;C、拓展字段&lt;/h3&gt;
&lt;p&gt;高度定制化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/39/391a3a9fa724a81fb53ac409adb4e3f9.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;e配置原语&#34;&gt;E、配置原语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://github.com/dapr/dapr/issues/2988&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*mfkRQZH3oNwAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
首先是分布式系统中经常使用的配置功能，应用一般使用配置中心来做开关或者动态调整应用的运行状态。Layotto 中配置模块的实现包括两部分，一个是对如何定义配置这种能力的 API 的思考，一个是具体的实现，下面逐个来看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想要定义一个能满足大部分实际生产诉求的配置 API 并不是一件容易的事，dapr 目前也缺失这个能力，因此我们跟阿里以及 dapr 社区一起合作，为如何定义一版合理的配置 API 进行了激烈讨论。&lt;/p&gt;
&lt;p&gt;目前讨论结果还没有最终确定，因此 Layotto 是基于我们提给社区的第一版草案进行实现，下面对我们的草案进行简要说明。&lt;/p&gt;
&lt;p&gt;我们先定义了一般配置所需的基本元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;appId：表示配置属于哪个应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key：配置的 key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;content：配置的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;group：配置所属的分组，如果一个 appId 下面的配置过多，我们可以给这些配置进行分组归类，便于维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外我们追加了两种高级特性，用来适配更加复杂的配置使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;label，用于给配置打标签，比如该配置属于哪个环境，在进行配置查询的时候，我们会使用 label + key 来查询配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tags，用户给配置追加的一些附加信息，如描述信息、创建者信息，最后修改时间等等，方便配置的管理，审计等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于上述定义的配置 API 的具体实现，目前支持查询、订阅、删除、创建、修改五种操作，其中订阅配置变更后的推送使用的是 gRPC 的 stream 特性，而底层实现这些配置能力的组件，我们选择了国内流行的 apollo，后面也会根据需求增加其他实现。&lt;/p&gt;
&lt;p&gt;level1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1582369/112835954-8d1abd00-90cc-11eb-9426-f26e14fb984f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;level2&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1582369/112836063-ae7ba900-90cc-11eb-8617-0939b13b6c40.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;levelx&amp;hellip;&lt;/p&gt;
&lt;p&gt;metadata&lt;/p&gt;
&lt;h3 id=&#34;grpc-原语&#34;&gt;G、RPC 原语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*i-JnSaeZbJ4AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
RPC 的能力大家不会陌生，这可能是微服务架构下最最基础的需求，对于 RPC 接口的定义，我们同样参考了 dapr 社区的定义，发现完全可以满足我们的需求，因此接口定义就直接复用 dapr 的，但目前 dapr 提供的 RPC 实现方案还比较薄弱，而 MOSN 经过多年迭代，能力已经非常成熟完善，因此我们大胆把 Runtime 跟 Service Mesh 两种思路结合在一起，把 MOSN 本身作为我们实现 RPC 能力的一个 Component，这样 Layotto 在收到 RPC 请求以后交给 MOSN 进行实际数据传输，这种方案可以通过 istio 动态改变路由规则，降级限流等等设置，相当于直接复用了 Service Mesh 的各种能力，这也说明 Runtime 不是要推翻 Service Mesh，而是要在此基础上继续向前迈一步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-rpc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;五capa-最佳实践&#34;&gt;五、Capa 最佳实践&lt;/h2&gt;
&lt;h3 id=&#34;a适配迁移之痛&#34;&gt;A、适配迁移之痛&lt;/h3&gt;
&lt;p&gt;如果要使用原生的Capa API，您的遗留系统需要面对较大的重构工作量。&lt;/p&gt;
&lt;p&gt;为了使迁移做到低成本，我们可以复用目前使用到的中间件API。&lt;/p&gt;
&lt;p&gt;通过开发一个适配层项目(提供相同的注解/接口调用方式)，将原中间件API的实现更改为Capa API。&lt;/p&gt;
&lt;p&gt;如此一来，应用程序只需要更改很少的代码(例如更换注解/接口的路径名)即可迁移到Capa架构。&lt;/p&gt;
&lt;p&gt;目前在Java语言上，Capa可以支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接入(携程)私有云SDK的适配层&lt;/li&gt;
&lt;li&gt;接入spring boot体系的适配层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-use.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;b现状和未来规划&#34;&gt;B、现状和未来规划&lt;/h3&gt;
&lt;p&gt;Capa(Java SDK)是面向Java应用实现Mecha架构的SDK解决方案，它目前支持以下领域的特：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Invocation (RPC服务调用)&lt;/li&gt;
&lt;li&gt;Configuration Centor (Configuration动态配置)&lt;/li&gt;
&lt;li&gt;Publish/Subscribe (Pub/Sub发布订阅)&lt;/li&gt;
&lt;li&gt;State Management (State状态管理)&lt;/li&gt;
&lt;li&gt;Application Log/Metrics/Traces (Telemetry可观测性)&lt;/li&gt;
&lt;li&gt;Database (SQL关系型数据库) -alpha&lt;/li&gt;
&lt;li&gt;Schedule (Schedule定时调度) -alpha&lt;/li&gt;
&lt;li&gt;Redis (Redis高度定制化存储) -planning&lt;/li&gt;
&lt;li&gt;Actuator (组件自身可观测性) -planning&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;六高阶拓展&#34;&gt;六、高阶拓展&lt;/h2&gt;
&lt;h3 id=&#34;awebassembly-的探索&#34;&gt;A、WebAssembly 的探索&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*-ACRSpqbuJ0AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
WebAssembly，简称 WASM，是一个二进制指令集，最初是跑在浏览器上来解决 JavaScript 的性能问题，但由于它良好的安全性，隔离性以及语言无关性等优秀特性，很快人们便开始让它跑在浏览器之外的地方，随着 WASI 定义的出现，只需要一个 WASM 运行时，就可以让 WASM 文件随处执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然 WebAssembly 可以在浏览器以外的地方运行，那么我们是否能把它用在 Serverless 领域？目前已经有人在这方面做了一些尝试，不过如果这种方案真的想落地的话，首先要考虑的就是如何解决运行中的 WebAssembly 对各种基础设施的依赖问题。&lt;/p&gt;
&lt;h4 id=&#34;webassembly-落地原理&#34;&gt;WebAssembly 落地原理&lt;/h4&gt;
&lt;p&gt;目前 MOSN 通过集成 WASM Runtime 的方式让 WASM 跑在 MOSN 上面，以此来满足对 MOSN 做自定义扩展的需求。同时，Layotto 也是构建在 MOSN 之上，因此我们考虑把二者结合在一起，实现方案如下图所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*U7UDRYyBOvIAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
开发者可以使用 Go/C++/Rust 等各种各样自己喜欢的语言来开发应用代码，然后把它们编译成 WASM 文件跑在 MOSN 上面，当 WASM 形态的应用在处理请求的过程中需要依赖各种分布式能力时就可以通过本地函数调用的方式调用 Layotto 提供的标准 API，这样直接解决了 WASM 形态应用的依赖问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 Layotto 提供了 Go 跟 Rust 版 WASM 的实现，虽然只支持 demo 级功能，但已经足够让我们看到这种方案的潜在价值。&lt;/p&gt;
&lt;p&gt;此外，WASM 社区目前还处于初期阶段，有很多地方需要完善，我们也给社区提交了一些 PR共同建设，为 WASM 技术的落地添砖加瓦。&lt;/p&gt;
&lt;h4 id=&#34;webassembly-落地展望&#34;&gt;WebAssembly 落地展望&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*NzwKRY2GZPcAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
虽然现在 Layotto 中对 WASM 的使用还处于试验阶段，但我们希望它最终可以成为 Serverless 的一种实现形态，如上图所示，应用通过各种编程语言开发，然后统一编译成 WASM 文件，最后跑在 Layotto+MOSN 上面，而对于应用的运维管理统一由 k8s、docker、prometheus 等产品负责。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;istio-wasm&#34;&gt;Istio Wasm&lt;/h4&gt;
&lt;p&gt;Istio 的扩展机制使用 Proxy-Wasm 应用二进制接口（ABI）规范，提供了一套代理无关的流媒体 API 和实用功能，可以用任何有合适 SDK 的语言来实现。&lt;/p&gt;
&lt;p&gt;扩展 Istio 的功能，满足你的特定需求，需要三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Golang 中实现你的插件功能。&lt;/li&gt;
&lt;li&gt;编译、构建，并将 Wasm 模块推送到符合 OCI 标准的 Docker 镜像仓库。&lt;/li&gt;
&lt;li&gt;使用 WasmPlugin 资源配置服务网格工作负载，以便从远程镜像仓库中拉取 Wasm 模块。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/VAwTCIP6RhqDNoBbmE8zVA&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;bebpf-的探索&#34;&gt;B、eBPF 的探索&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ebpf-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ebpf-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/W9NySdKnxuQ6S917QQn3PA&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;七社区规划&#34;&gt;七、社区规划&lt;/h2&gt;
&lt;p&gt;最后来看下社区的做的一些事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://zhuanlan.zhihu.com/p/435012312?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=618742049890111488&amp;amp;utm_content=group2_article&amp;amp;utm_campaign=shareopn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;a建设更多的api标准&#34;&gt;A、建设更多的API标准&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*OpQTRqoMpK0AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
上图列出了 Layotto 跟 dapr 现有的能力对比，在 Layotto 的开发过程中，我们借鉴 dapr 的思路，始终以优先复用、其次开发为原则，旨在达成共建的目标，而对于正在建设或者未来要建设的能力来说，我们计划优先在 Layotto 上落地，然后再提给社区，合并到标准 API，鉴于社区异步协作的机制，沟通成本较高，因此短期内可能 Layotto 的 API 会先于社区，但长期来看一定会统一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分布式锁API&lt;/li&gt;
&lt;li&gt;文件系统API&lt;/li&gt;
&lt;li&gt;延迟消息API&lt;/li&gt;
&lt;li&gt;密钥管理API&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bapi-共建计划&#34;&gt;B、API 共建计划&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*GAe8QqZ03eoAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
关于如何定义一套标准的 API 以及如何让 Layotto 可以跑在 envoy 上等等事项，我们已经在各个社区进行了深入讨论，并且以后也还会继续推进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 API 标准化的建设是一件需要长期推动的事情，同时标准化意味着不是满足一两种场景，而是尽可能的适配大多数使用场景。&lt;/p&gt;
&lt;h3 id=&#34;c可扩展api架构&#34;&gt;C、可扩展API架构&lt;/h3&gt;
&lt;p&gt;参考OS领域当年是怎么定API的，我们可以把Runtime API设计成多层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;社区标准API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;企业内部的私有API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基础设施特定API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别对应OS领域的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POSIX API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各种Unix-like系统自己的System Call&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊硬件提供的特殊功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这种思想，尝试让Runtime支持API插件，让用户自己实现自己的私有API&lt;/p&gt;
&lt;h3 id=&#34;d直接支持行业标准协议&#34;&gt;D、直接支持行业标准协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接支持SQL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接支持Redis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要进一步讨论。&lt;/p&gt;
&lt;h3 id=&#34;e开源协同&#34;&gt;E、开源协同&lt;/h3&gt;
&lt;p&gt;各个Mecha项目积极交流，合作共建，互为补充。&lt;/p&gt;
&lt;h2 id=&#34;八云厂商的支持&#34;&gt;八、云厂商的支持&lt;/h2&gt;
&lt;h3 id=&#34;a阿里云在内部的落地&#34;&gt;A、阿里云在内部的落地&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://blog.dapr.io/posts/2021/03/19/how-alibaba-is-using-dapr/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;faas与多语言应用&#34;&gt;Faas与多语言应用&lt;/h4&gt;
&lt;p&gt;FaaS 对多语言支持的需求强烈，并不局限于 Java。但实际上，由于成本和时间限制，用所有语言重新开发客户是不切实际的。&lt;/p&gt;
&lt;p&gt;借助 Dapr，阿里巴巴解决了 FaaS 的多语言问题，帮助客户通过 FaaS 提高开发效率。&lt;/p&gt;
&lt;h4 id=&#34;适配基于java的遗留系统&#34;&gt;适配基于Java的遗留系统&lt;/h4&gt;
&lt;p&gt;我们旨在消除业务开发团队进行代码更改以减少迁移期间对业务应用程序的影响的需要。在将这些遗留系统迁移到 Dapr 时，我们设计了一个 Java 适配层，它将原始 Java 调用适配到 Dapr 客户端 API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.dapr.io/posts/2021/03/19/how-alibaba-is-using-dapr/multiple-langurage_hu5d98ca782c8bcb789c89210a0f8e3e46_207793_1500x0_resize_q75_box.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;混合云云到云迁移&#34;&gt;混合云：云到云迁移&lt;/h4&gt;
&lt;p&gt;Dapr 的可移植性将钉钉文档的上层应用与消息系统等底层基础设施解耦。从而，钉钉文档实现了不同云平台之间的平滑迁移。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.dapr.io/posts/2021/03/19/how-alibaba-is-using-dapr/cloud-migration_hu5d98ca782c8bcb789c89210a0f8e3e46_276395_1500x0_resize_q75_box.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;b微软azure的托管支持&#34;&gt;B、微软Azure的托管支持&lt;/h3&gt;
&lt;p&gt;微软在 Ignite 2021 大会上发布了预览版的Azure Container Apps，这是一个完全托管的无服务器容器运行时，用于大规模构建和运行现代应用程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用分布式应用运行时 Dapr 轻松构建和连接微服务。 Dapr允许你构建松耦合的微服务应用程序，而不是构建一个分布式单体应用，在Azure Container Apps里我，利用 Dapr 及其组件构建具有弹性、可扩展性和松耦合的应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://www.cnblogs.com/shanyou/p/15509042.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;cdapr-加入-cncf-孵化器&#34;&gt;C、Dapr 加入 CNCF 孵化器&lt;/h3&gt;
&lt;p&gt;CNCF 托管了许多与 Dapr 紧密结合的项目。例如，Dapr 使用 gRPC 作为它的主要 RPC 堆栈。OpenTelemetry 用作 Dapr 的遥测协议，CloudEvents 用于标准化 Dapr 的 Pub/Sub API 中的消息格式，SPIFFE 用作 Dapr 的访问列表特性的身份格式，Prometheus 用作 Dapr 端点的指标格式，Dapr 支持 NATS 的 Pub/Sub 实现以及 Open Policy Agent。此外，Dapr 使用 Operator 在 Kubernetes 上原生运行，并使用 Helm 作为主要部署机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/8qnmL12JrESwJg3RsSelJQ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/slog.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;主要参考文献&#34;&gt;主要参考文献&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mosn.io/layotto/#/zh/blog/mosn-subproject-layotto-opening-a-new-chapter-in-service-grid-application-runtime/index&#34;&gt;https://mosn.io/layotto/#/zh/blog/mosn-subproject-layotto-opening-a-new-chapter-in-service-grid-application-runtime/index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: </title>
      <link>https://reactivegroup.github.io/capa.io/blog/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/1/01/01/</guid>
      <description>
        
        
        &lt;h4 id=&#34;envoy-http重定向&#34;&gt;envoy http重定向&lt;/h4&gt;
&lt;p&gt;配置http过滤器类型为envoy.filters.http.router，我们的用例中需要这个过滤器将地址127.0.0.1:10000上收到的请求路由到www.envoyproxy.io，除此之外，envoy还有其他过滤器，比如带宽限制过滤器envoy.filters.http.bandwidth_limit,速率限制过滤器envoy.filters.http.ratelimit等。具体可参考：http 过滤器。&lt;/p&gt;
&lt;p&gt;指定了cluster的名称为service_envoyproxy_io， 上文中的listener监听到的请求在37行就会被路由到该cluster，listener_0监听来自下游主机的请求后，路由到service_envoyproxy_io，service_envoyproxy_io会将该请求发送给相应的上游端点进行处理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ciocso.com/article/730.html&#34;&gt;https://www.ciocso.com/article/730.html&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: </title>
      <link>https://reactivegroup.github.io/capa.io/blog/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/1/01/01/</guid>
      <description>
        
        
        &lt;p&gt;原文链接：https://blog.csdn.net/wyy4045/article/details/119170348&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/&#34;&gt;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
