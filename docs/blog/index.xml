<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Capa – Capa Blog</title>
    <link>https://reactivegroup.github.io/capa.io/blog/</link>
    <description>Recent content in Capa Blog on Capa</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://reactivegroup.github.io/capa.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Blog: AppMesh Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/22/appmesh-landscape/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/22/appmesh-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;二appmesh-运维&#34;&gt;二、AppMesh 运维&lt;/h2&gt;
&lt;h3 id=&#34;故障排除&#34;&gt;故障排除&lt;/h3&gt;
&lt;p&gt;跟踪控制器日志：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;APPMESH_SYSTEM_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;appmesh-system
kubectl logs -n &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPMESH_SYSTEM_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; -f --since 10s &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;$(&lt;/span&gt;kubectl get pods -n &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPMESH_SYSTEM_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; -o name &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt; grep controller&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;尾特使日志：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;APPLICATION_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&amp;lt;your namespace&amp;gt;
&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;APPLICATION&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&amp;lt;your pod or deployment&amp;gt; &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# i.e. deploy/my-app&lt;/span&gt;
kubectl logs -n &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPLICATION_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt; &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPLICATION_POD&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34; envoy -f --since 10s
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看特使配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;APPLICATION_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&amp;lt;your namespace&amp;gt;
&lt;span style=&#34;color:#204a87&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;APPLICATION&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&amp;lt;your pod&amp;gt;
kubectl port-forward -n &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPLICATION_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;$(&lt;/span&gt;kubectl get pod -n &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPLICATION_NAMESPACE&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt; grep &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;APPLICATION&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt;awk &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;9901&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后导航到localhost:9901/索引或localhost:9901/config_dump特使配置。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Dubbo Invoke流程</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/22/dubbo-invoke%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/22/dubbo-invoke%E6%B5%81%E7%A8%8B/</guid>
      <description>
        
        
        &lt;h3 id=&#34;概要&#34;&gt;概要&lt;/h3&gt;
&lt;p&gt;梳理Dubbo的调用链路流程，分析其设计理念和思路，以及阅读其中关键步骤的源码逻辑&lt;/p&gt;
&lt;h4 id=&#34;review&#34;&gt;Review&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用流程主要围绕&lt;code&gt;Protocol&lt;/code&gt;/&lt;code&gt;Invoker&lt;/code&gt;/&lt;code&gt;Filter&lt;/code&gt;三个接口进行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Protocol&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Exporter&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;export&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;refer&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Class&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;URL&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroy&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Node&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoke&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invocation&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invocation&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroy&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Filter&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;BaseFilter&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoke&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invocation&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invocation&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;整体流程&#34;&gt;整体流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;初始化流程&#34;&gt;初始化流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;初始化配置相关&amp;hellip;&amp;hellip;.&lt;/li&gt;
&lt;li&gt;初始化&lt;code&gt;Protocol&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化&lt;code&gt;Invoker&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化底层资源&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;调用流程&#34;&gt;调用流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;Invoker&lt;/code&gt;，做一些逻辑&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Filter&lt;/code&gt;，做一些逻辑&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;Invoker&lt;/code&gt;，做一些逻辑&lt;/li&gt;
&lt;li&gt;调用底层资源&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;简化设计&#34;&gt;简化设计&lt;/h2&gt;
&lt;p&gt;从一个Client开始&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;h4 id=&#34;1-直接调用&#34;&gt;1. 直接调用&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-责任链模式&#34;&gt;2. 责任链模式&lt;/h4&gt;
&lt;p&gt;解决函数逻辑的水平拓展问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;定义接口：&lt;code&gt;Response invoke(Request request);&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Node&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoke&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invocation&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invocation&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroy&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-过滤器插件&#34;&gt;3. 过滤器插件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;在重要的过程上设置拦截接口&#34;&gt;在重要的过程上设置拦截接口&lt;/h4&gt;
&lt;p&gt;如果你要写个远程调用框架，那远程调用的过程应该有一个统一的拦截接口。如果你要写一个 ORM 框架，那至少 SQL 的执行过程，Mapping 过程要有拦截接口；如果你要写一个 Web 框架，那请求的执行过程应该要有拦截接口，等等。没有哪个公用的框架可以 Cover 住所有需求，允许外置行为，是框架的基本扩展方式。这样，如果有人想在远程调用前，验证下令牌，验证下黑白名单，统计下日志；如果有人想在 SQL 执行前加下分页包装，做下数据权限控制，统计下 SQL 执行时间；如果有人想在请求执行前检查下角色，包装下输入输出流，统计下请求量，等等，就可以自行完成，而不用侵入框架内部。&lt;strong&gt;拦截接口，通常是把过程本身用一个对象封装起来，传给拦截器链，比如：远程调用主过程为 invoke()，那拦截器接口通常为 invoke(Invocation)，Invocation 对象封装了本来要执行过程的上下文，并且 Invocation 里有一个 invoke() 方法，由拦截器决定什么时候执行，同时，Invocation 也代表拦截器行为本身，这样上一拦截器的 Invocation 其实是包装的下一拦截器的过程，直到最后一个拦截器的 Invocation 是包装的最终的 invoke() 过程&lt;/strong&gt;；同理，SQL 主过程为 execute()，那拦截器接口通常为 execute(Execution)，原理一样。当然，实现方式可以任意，上面只是举例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Filter&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;BaseFilter&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoke&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invocation&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invocation&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;装饰模式/组合模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4-领域模型的设计&#34;&gt;4. 领域模型的设计&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;重资源 -&amp;gt; 资源的管理 -&amp;gt; 生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资源的管理：&lt;/p&gt;
&lt;p&gt;共享、创建、释放、生命周期&amp;hellip;&amp;hellip;..&lt;/p&gt;
&lt;p&gt;链路治理、上下文、组装&amp;hellip;&amp;hellip;..&lt;/p&gt;
&lt;h4 id=&#34;领域模型&#34;&gt;领域模型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 Dubbo 的核心领域模型中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。&lt;/li&gt;
&lt;li&gt;Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。&lt;/li&gt;
&lt;li&gt;Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Protocol&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Exporter&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;export&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;refer&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Class&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;URL&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroy&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;共享资源谁持有？&lt;/p&gt;
&lt;p&gt;缓存在哪里存储？&lt;/p&gt;
&lt;p&gt;线程安全？&lt;/p&gt;
&lt;p&gt;单例还是New？&lt;/p&gt;
&lt;h4 id=&#34;服务域实体域会话域分离&#34;&gt;服务域/实体域/会话域分离&lt;/h4&gt;
&lt;p&gt;任何框架或组件，总会有核心领域模型，比如：Spring 的 Bean，Struts 的 Action，Dubbo 的 Service，Napoli 的 Queue 等等。这个核心领域模型及其组成部分称为实体域，它代表着我们要操作的目标本身。**实体域通常是线程安全的，不管是通过不变类，同步状态，或复制的方式。**①&lt;/p&gt;
&lt;p&gt;服务域也就是行为域，它是组件的功能集，同时也负责实体域和会话域的生命周期管理， 比如 Spring 的 ApplicationContext，Dubbo 的 ServiceManager 等。**服务域的对象通常会比较重，而且是线程安全的，并以单一实例服务于所有调用。**②&lt;/p&gt;
&lt;p&gt;什么是会话？就是一次交互过程。会话中重要的概念是上下文，什么是上下文？比如我们说：“老地方见”，这里的“老地方”就是上下文信息。为什么说“老地方”对方会知道，因为我们前面定义了“老地方”的具体内容。所以说，上下文通常持有交互过程中的状态变量等。&lt;strong&gt;会话对象通常较轻，每次请求都重新创建实例，请求结束后销毁。简而言之：把元信息交由实体域持有&lt;/strong&gt;③，把一次请求中的临时状态由会话域持有，由服务域贯穿整个过程。&lt;/p&gt;
&lt;p&gt;① &lt;code&gt;Invoker&lt;/code&gt;仅维护自己的状态，类似Actor设计模式&lt;/p&gt;
&lt;p&gt;② &lt;code&gt;Protocol&lt;/code&gt;初始化为单例，并且持有缓存Map&lt;/p&gt;
&lt;p&gt;③ &lt;code&gt;Invoker&lt;/code&gt;中存储默认元信息，临时信息存储到&lt;code&gt;Invocation&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;=&amp;gt; show code&lt;/p&gt;
&lt;h4 id=&#34;41-资源的销毁&#34;&gt;4.1 资源的销毁&lt;/h4&gt;
&lt;p&gt;由服务域管理资源的生命周期，并委托给实体域执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Protocol&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Exporter&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;export&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;refer&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Class&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;URL&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroy&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Node&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoke&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invocation&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invocation&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroy&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;42-状态的监听&#34;&gt;4.2 状态的监听&lt;/h4&gt;
&lt;h4 id=&#34;重要的状态的变更发送事件并留出监听接口&#34;&gt;重要的状态的变更发送事件并留出监听接口&lt;/h4&gt;
&lt;p&gt;这里先要讲一个事件和上面拦截器的区别，拦截器是干预过程的，它是过程的一部分，是基于过程行为的，而事件是基于状态数据的，任何行为改变的相同状态，对事件应该是一致的。事件通常是事后通知，是一个 Callback 接口，方法名通常是过去式的，比如 onChanged()。比如远程调用框架，当网络断开或连上应该发出一个事件，当出现错误也可以考虑发出一个事件，这样外围应用就有可能观察到框架内部的变化，做相应适应。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;InvokerListener&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;referred&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;throws&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;RpcException&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;destroyed&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invoker&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;43-纵向拓展&#34;&gt;4.3 纵向拓展&lt;/h4&gt;
&lt;p&gt;SPI，微内核，插件化&lt;/p&gt;
&lt;h4 id=&#34;微核插件式平等对待第三方&#34;&gt;微核插件式，平等对待第三方&lt;/h4&gt;
&lt;p&gt;大凡发展的比较好的框架，都遵守微核的理念。Eclipse 的微核是 OSGi， Spring 的微核是 BeanFactory，Maven 的微核是 Plexus。通常核心是不应该带有功能性的，而是一个生命周期和集成容器，这样各功能可以通过相同的方式交互及扩展，并且任何功能都可以被替换。如果做不到微核，至少要平等对待第三方，即原作者能实现的功能，扩展者应该可以通过扩展的方式全部做到。原作者要把自己也当作扩展者，这样才能保证框架的可持续性及由内向外的稳定性。&lt;/p&gt;
&lt;p&gt;引入配置模块，担当微内核。并负责&lt;code&gt;Protocol&lt;/code&gt;的初始化启动（Protocol再负责下层的初始化）&lt;/p&gt;
&lt;h4 id=&#34;44-完善的分层&#34;&gt;4.4 完善的分层&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;config 配置层&lt;/strong&gt;：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proxy 服务代理层&lt;/strong&gt;：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;registry 注册中心层&lt;/strong&gt;：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cluster 路由层&lt;/strong&gt;：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance&lt;/li&gt;
&lt;li&gt;monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;protocol 远程调用层&lt;/strong&gt;：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter&lt;/li&gt;
&lt;li&gt;exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer&lt;/li&gt;
&lt;li&gt;transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec&lt;/li&gt;
&lt;li&gt;serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他层次以插件的方式装配到config里，核心仍然是&lt;code&gt;Protocol&lt;/code&gt;层。功能要么伪装成&lt;code&gt;Invoker&lt;/code&gt;，要么在初始化时进行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 RPC 中，Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_7.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;层级关系：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-system
-config
-proxy
-registry
-cluster
-monitor
-protocol
    -invoker
        -exchange
        -...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_9.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;5-异步调用&#34;&gt;5. 异步调用&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Serializable&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;whenCompleteWithContext&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;BiConsumer&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Result&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Throwable&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;fn&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;重点关注点&#34;&gt;重点关注点&lt;/h3&gt;
&lt;p&gt;结合一开始的大概流程&amp;hellip;&lt;/p&gt;
&lt;h4 id=&#34;1-protocol初始化流程&#34;&gt;1. protocol初始化流程&lt;/h4&gt;
&lt;p&gt;初始化的时候做了什么？集群？注册发现？代理封装？&lt;/p&gt;
&lt;p&gt;资源如何加载？如何缓存？连接池？线程池？&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;..&lt;/p&gt;
&lt;h4 id=&#34;2-invoke流程&#34;&gt;2. invoke流程&lt;/h4&gt;
&lt;p&gt;实际调用过程的流程？有哪些逻辑步骤？&lt;/p&gt;
&lt;p&gt;负载均衡？重试？监控？序列化？&lt;/p&gt;
&lt;p&gt;同步异步？流式调用？&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;..&lt;/p&gt;
&lt;h2 id=&#34;invoke流程解读&#34;&gt;Invoke流程解读&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_10.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;调用流程-1&#34;&gt;调用流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_11.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;源码分析&#34;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;关键Invoker的逻辑：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AbstractInvoker&lt;/code&gt;: 3个步骤，（PR：https://github.com/apache/dubbo/pull/7952）&lt;/p&gt;
&lt;p&gt;具体逻辑在&lt;code&gt;doInvoke&lt;/code&gt;中&lt;/p&gt;
&lt;h4 id=&#34;failoverclusterinvoker&#34;&gt;&lt;code&gt;FailoverClusterInvoker&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;当调用失败时，记录初始错误并重试其他调用程序(重试n次，这意味着最多将调用n个不同的调用程序)注意，重试会导致延迟。 故障转移&lt;/p&gt;
&lt;p&gt;图中方法：list、route、select&lt;/p&gt;
&lt;p&gt;什么时候会重试？非biz异常，但粒度很粗&amp;hellip;.（Issue相关）&lt;/p&gt;
&lt;h4 id=&#34;listenerinvokerwrapper&#34;&gt;&lt;code&gt;ListenerInvokerWrapper&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;注册invoker的listener，并进行操作，装饰模式&lt;/p&gt;
&lt;p&gt;改进：观察者模式+生命周期&lt;/p&gt;
&lt;h4 id=&#34;filterchainnode&#34;&gt;&lt;code&gt;FilterChainNode&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;实际上是Invoker，但内部保存了Filter&lt;/p&gt;
&lt;p&gt;Invoker装饰，Filter适配，两者的组合&lt;/p&gt;
&lt;h4 id=&#34;dubboinvoker&#34;&gt;&lt;code&gt;DubboInvoker&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;可以看到：Invoker层持有下层的资源管理&lt;/p&gt;
&lt;p&gt;接下来就是&lt;code&gt;excahnge&lt;/code&gt;层的逻辑&lt;/p&gt;
&lt;h4 id=&#34;tripleinvoker&#34;&gt;&lt;code&gt;TripleInvoker&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;直接持有底层netty资源，比较粗糙&lt;/p&gt;
&lt;p&gt;=&amp;gt; show code&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;h3 id=&#34;1层次结构&#34;&gt;1.层次结构&lt;/h3&gt;
&lt;p&gt;层级关系：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-system
-config
-proxy
-registry
-cluster
-monitor
-protocol
    -invoker
        -exchange
        -...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2调用流程&#34;&gt;2.调用流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/dubbo/img_12.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3设计模式&#34;&gt;3.设计模式&lt;/h3&gt;
&lt;p&gt;责任链：Invoker&lt;/p&gt;
&lt;p&gt;适配器：适配到Invoker责任链中&lt;/p&gt;
&lt;p&gt;装饰：对Invoker进行增强&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;4设计优化&#34;&gt;4.设计优化&lt;/h3&gt;
&lt;p&gt;Invoker调用链：√，整个系统的核心，插件化功能采用拓展接口的方式，各个模块功能比较明确&lt;/p&gt;
&lt;p&gt;Lifecycle生命周期：不完全，没有完整的生命周期；对于生命周期的事件处理比较硬编码&lt;/p&gt;
&lt;p&gt;Listener：装饰的比较硬编码，事件阶段不够全，拓展性不够好&lt;/p&gt;
&lt;p&gt;Filter：采用装饰模型而非组合模型，拓展性较差；嵌套层级深，调试时链路不清晰&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;..&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Dubbo Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/22/dubbo-landscape/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/22/dubbo-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;dubbo整体设计概述&#34;&gt;Dubbo整体设计概述&lt;/h2&gt;
&lt;h3 id=&#34;ainvoker责任链设计&#34;&gt;A、Invoker责任链设计&lt;/h3&gt;
&lt;h3 id=&#34;bfilter拓展机制设计&#34;&gt;B、Filter拓展机制设计&lt;/h3&gt;
&lt;h3 id=&#34;cmanager容器管理设计&#34;&gt;C、Manager容器管理设计&lt;/h3&gt;
&lt;h3 id=&#34;d&#34;&gt;D、&lt;/h3&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Nginx Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/22/nginx-landscape/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/22/nginx-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;一nginx-功能&#34;&gt;一、Nginx 功能&lt;/h2&gt;
&lt;h3 id=&#34;a跨域问题&#34;&gt;A、跨域问题&lt;/h3&gt;
&lt;h4 id=&#34;关键字&#34;&gt;关键字：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;OPTIONS预检请求&lt;/li&gt;
&lt;li&gt;CORS跨域校验&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;资料&#34;&gt;资料：&lt;/h4&gt;
&lt;p&gt;跨域中一些ngxin的配置：https://juejin.cn/post/6995374680114741279&lt;/p&gt;
&lt;p&gt;跨域的解释：https://juejin.cn/post/6844903938232156167#heading-46&lt;/p&gt;
&lt;p&gt;CORS：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&lt;/p&gt;
&lt;h2 id=&#34;二nginx-运维&#34;&gt;二、Nginx 运维&lt;/h2&gt;
&lt;h4 id=&#34;快速部署&#34;&gt;快速部署&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/&#34;&gt;https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;常用目录&#34;&gt;常用目录&lt;/h4&gt;
&lt;p&gt;配置文件 /etc/nginx/conf.d&lt;/p&gt;
&lt;p&gt;默认日志 /var/logs/nginx&lt;/p&gt;
&lt;p&gt;配置日志 /etc/nginx/logs/&lt;/p&gt;
&lt;h4 id=&#34;常用命令&#34;&gt;常用命令&lt;/h4&gt;
&lt;p&gt;测试：nginx -t&lt;/p&gt;
&lt;p&gt;重启：nginx -s reload&lt;/p&gt;
&lt;p&gt;查看日志：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tail -n 10 xxx.log&lt;/li&gt;
&lt;li&gt;head -n 10 xxx.log&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;域名解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/etc/resov.conf&lt;/li&gt;
&lt;li&gt;nslookup
&lt;ul&gt;
&lt;li&gt;apt-get install dnsutils&lt;/li&gt;
&lt;li&gt;nslookup &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;h4 id=&#34;日志&#34;&gt;日志&lt;/h4&gt;
&lt;p&gt;error_log    logs/error_&lt;a href=&#34;http://www.abc.com.log&#34;&gt;www.abc.com.log&lt;/a&gt;    error;&lt;/p&gt;
&lt;h4 id=&#34;proxy&#34;&gt;proxy&lt;/h4&gt;
&lt;p&gt;如果proxy_pass中hostname使用了占位符，需要指定resovler的dns服务器ip&lt;/p&gt;
&lt;h4 id=&#34;参数&#34;&gt;参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用$arg_xxx来获取get中的参数&lt;/li&gt;
&lt;li&gt;使用$http_xxx来获取header中的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;header&#34;&gt;header&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;add_header 是当请求从 server 端回来时，Nginx 再往这个 response 里添加一些额外的 reponse header 然后发送给 客户端。&lt;/li&gt;
&lt;li&gt;proxy_set_header 是当请求从客户端发出时，Nginx接收到 request 再往请求里添加一些额外的 request header 然后发送给 服务端。
&lt;ul&gt;
&lt;li&gt;常见的一些需要设置 proxy_set_header 的场景，比如说，有些 server 可能需要验证 Host，这个时候，就可以使用 proxy_set_header 伪造一个 Host 来骗过服务端。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;经验&#34;&gt;经验&lt;/h3&gt;
&lt;h4 id=&#34;proxy-1&#34;&gt;proxy&lt;/h4&gt;
&lt;p&gt;使用resolver指定dns服务器时，hostname要带上 .svc.cluster.local&lt;/p&gt;
&lt;p&gt;可以查看/etc/resov.conf中的dns服务器，来指定nginx的resovler&lt;/p&gt;
&lt;h3 id=&#34;参考资料&#34;&gt;参考资料&lt;/h3&gt;
&lt;h4 id=&#34;变量名&#34;&gt;变量名：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/dadonggg/p/7797281.html&#34;&gt;https://www.cnblogs.com/dadonggg/p/7797281.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;代理配置&#34;&gt;代理配置：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000019894251&#34;&gt;https://segmentfault.com/a/1190000019894251&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;service跨namespace&#34;&gt;service跨namespace：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1718427&#34;&gt;https://cloud.tencent.com/developer/article/1718427&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Envoy Gateway</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/21/envoy-gateway/</link>
      <pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/21/envoy-gateway/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;重要参考资料：https://mp.weixin.qq.com/s/t1ppAQfm0cPmqhxEARB03Q&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一envoy-gateway&#34;&gt;一、Envoy Gateway&lt;/h2&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Mosn Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/20/mosn-landscape/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/20/mosn-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;一mosn-常用概念&#34;&gt;一、Mosn 常用概念&lt;/h2&gt;
&lt;h3 id=&#34;a流量劫持&#34;&gt;A、流量劫持&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;MOSN 作为 Sidecar 使用时的流量劫持方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MOSN 作为 Sidecar 和业务容器部署在同一个 Pod 中时，需要使得业务应用的 Inbound 和 Outbound 服务请求都能够经过 Sidecar 处理。&lt;strong&gt;区别于 Istio 社区使用 iptables 做流量透明劫持&lt;/strong&gt;，MOSN 目前使用的是流量接管方案，并在积极探索适用于大规模流量下的透明劫持方案&lt;/p&gt;
&lt;h4 id=&#34;流量接管&#34;&gt;流量接管&lt;/h4&gt;
&lt;p&gt;区别于 Istio 社区的 iptables 流量劫持方案，MOSN 使用的流量接管的方案如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假设服务端运行在 1.2.3.4 这台机器上，监听 20880 端口，首先服务端会向自己的 Sidecar 发起服务注册请求，告知 Sidecar 需要注册的服务以及 IP + 端口（1.2.3.4:20880）&lt;/li&gt;
&lt;li&gt;服务端的 Sidecar 会向服务注册中心（如 SOFA Registry）发起服务注册请求，告知需要注册的服务以及 IP + 端口，不过这里需要注意的是注册上去的并不是业务应用的端口（20880），而是 Sidecar 自己监听的一个端口（例如：20881）&lt;/li&gt;
&lt;li&gt;调用端向自己的 Sidecar 发起服务订阅请求，告知需要订阅的服务信息&lt;/li&gt;
&lt;li&gt;调用端的 Sidecar 向调用端推送服务地址，这里需要注意的是推送的 IP 是本机，端口是调用端的 Sidecar 监听的端口（例如 20882）&lt;/li&gt;
&lt;li&gt;调用端的 Sidecar 会向服务注册中心（如 SOFA Registry）发起服务订阅请求，告知需要订阅的服务信息；&lt;/li&gt;
&lt;li&gt;服务注册中心（如 SOFA Registry）向调用端的 Sidecar 推送服务地址（1.2.3.4:20881）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;服务调用过程&#34;&gt;服务调用过程&lt;/h4&gt;
&lt;p&gt;经过上述的服务发现过程，流量转发过程就显得非常自然了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用端拿到的服务端地址是 127.0.0.1:20882，所以就会向这个地址发起服务调用&lt;/li&gt;
&lt;li&gt;调用端的 Sidecar 接收到请求后，通过解析请求头，可以得知具体要调用的服务信息，然后获取之前从服务注册中心返回的地址后就可以发起真实的调用（1.2.3.4:20881）&lt;/li&gt;
&lt;li&gt;服务端的 Sidecar 接收到请求后，经过一系列处理，最终会把请求发送给服务端（127.0.0.1:20880）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;b透明劫持&#34;&gt;B、透明劫持&lt;/h3&gt;
&lt;p&gt;上文通过在服务注册过程中把服务端地址替换成本机监听端口实现了轻量级的“流量劫持”，在存在注册中心，且调用端和服务端同时使用特定SDK的场景中可以很好的工作，如果不满足这两个条件，则无法流量劫持。为了降低对于应用程序的要求，需要引入透明劫持。&lt;/p&gt;
&lt;h4 id=&#34;使用-iptables-做流量劫持&#34;&gt;使用 iptables 做流量劫持&lt;/h4&gt;
&lt;p&gt;iptables 通过 NAT 表的 redirect 动作执行流量重定向，通过 syn 包触发新建 nefilter 层的连接，后续报文到来时查找连接转换目的地址与端口。新建连接时同时会记录下原始目的地址，应用程序可以通过(SOL_IP、SO_ORIGINAL_DST)获取到真实的目的地址。&lt;/p&gt;
&lt;p&gt;iptables 劫持原理如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/docs/products/structure/traffic-hijack/iptables.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用 iptables 做流量劫持时存在的问题
目前 Istio 使用 iptables 实现透明劫持，主要存在以下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要借助于 conntrack 模块实现连接跟踪，在连接数较多的情况下，会造成较大的消耗，同时可能会造成 track 表满的情况，为了避免这个问题，业内有关闭 conntrack 的做法。&lt;/li&gt;
&lt;li&gt;iptables 属于常用模块，全局生效，不能显式的禁止相关联的修改，可管控性比较差。&lt;/li&gt;
&lt;li&gt;iptables 重定向流量本质上是通过 loopback 交换数据，outbond 流量将两次穿越协议栈，在大并发场景下会损失转发性能。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;透明劫持方案优化&#34;&gt;透明劫持方案优化&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;使用 tproxy 处理 inbound 流量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tproxy 可以用于 inbound 流量的重定向，且无需改变报文中的目的 IP/端口，不需要执行连接跟踪，不会出现 conntrack 模块创建大量连接的问题。受限于内核版本，tproxy 应用于 outbound 存在一定缺陷。目前 Istio 支持通过 tproxy 处理 inbound 流量。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用 hook connect 处理 outbound 流量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了适配更多应用场景，outbound 方向通过 hook connect 来实现，实现原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/docs/products/structure/traffic-hijack/iptables.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;无论采用哪种透明劫持方案，均需要解决获取真实目的 IP/端口的问题，使用 iptables 方案通过 getsockopt 方式获取，tproxy 可以直接读取目的地址，通过修改调用接口，hook connect 方案读取方式类似于tproxy。&lt;/p&gt;
&lt;p&gt;实现透明劫持后，在内核版本满足要求（4.16以上）的前提下，通过 sockmap 可以缩短报文穿越路径，进而改善 outbound 方向的转发性能。&lt;/p&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;总结来看，如果应用程序通过注册中心发布/订阅服务时，可以结合注册中心劫持流量；在需要用到透明劫持的场景，如果性能压力不大，使用 iptables redirect 即可，大并发压力下使用 tproxy 与hook connect 结合的方案。&lt;/p&gt;
&lt;h3 id=&#34;cmosn-平滑升级原理解析&#34;&gt;C、MOSN 平滑升级原理解析&lt;/h3&gt;
&lt;p&gt;本文介绍 MOSN 支持平滑升级的原因和解决方案，对于平滑升级的一些基础概念，大家可以通过 Nginx vs Enovy vs Mosn 平滑升级原理解析了解。&lt;/p&gt;
&lt;p&gt;先简单介绍一下为什么 Nginx 和 Envoy 不需要具备 MOSN 这样的连接无损迁移方案，主要还是跟业务场景相关，Nginx 和 Envoy 主要支持的是 HTTP1 和 HTTP2 协议，HTTP1使用 connection: Close，HTTP2 使用 Goaway Frame 都可以让 Client 端主动断链接，然后新建链接到新的 New process，但是针对 Dubbo、SOFA PRC 等常见的多路复用协议，它们是没有控制帧，Old process 的链接如果断了就会影响请求的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：Envoy热重启&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般的升级做法就是切走应用的流量，比如自己UnPub掉服务，等待一段时间没有请求之后，升级MOSN，升级好之后再Pub服务，整个过程比较耗时，并且会有一段时间是不提供服务的，还要考虑应用的水位，在大规模场景下，就很难兼顾评估。MOSN 为了满足自身业务场景，开发了长连接迁移方案，把这条链接迁移到 New process 上，整个过程对 Client 透明，不需要重新建链接，达到请求无损的平滑升级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/docs/products/structure/smooth-upgrade/reqeust-smooth-upgrade-process.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dmosn-多协议机制解析&#34;&gt;D、MOSN 多协议机制解析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mosn.io/blog/posts/multi-protocol-deep-dive/&#34;&gt;https://mosn.io/blog/posts/multi-protocol-deep-dive/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于 MOSN 本身的扩展机制，我们完成了最初版本的协议扩展接入。但是在实践过程中，我们发现这并不是一件容易的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相比编解码，协议自身的处理以及与框架集成才是其中最困难的环节，需要理解并实现包括请求生命周期、多路复用处理、链接池等等机制；&lt;/li&gt;
&lt;li&gt;社区主流的 xDS 路由配置是面向 HTTP 协议的，无法直接支持私有协议，存在适配成本；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这些实践痛点，我们设计了 MOSN 多协议框架，希望可以降低私有协议的接入成本，加快普及 ServiceMesh 架构的落地推进。&lt;/p&gt;
&lt;h4 id=&#34;常见的协议扩展思路初探&#34;&gt;常见的协议扩展思路初探&lt;/h4&gt;
&lt;p&gt;第一个要介绍的是目前发展势头强劲的 Envoy。从图上可以看出，Envoy 支持四层的读写过滤器扩展、基于 HTTP 的七层读写过滤器扩展以及对应的 Router/Upstream 实现。如果想要基于 Envoy 的扩展框架实现 L7 协议接入，目前的普遍做法是基于 L4 filter 封装相应的 L7 codec，在此基础之上再实现对应的协议路由等能力，无法复用 HTTP L7 的扩展框架。&lt;/p&gt;
&lt;h3 id=&#34;emosn-扩展机制解析&#34;&gt;E、MOSN 扩展机制解析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://mosn.io/blog/posts/mosn-extensions/&#34;&gt;https://mosn.io/blog/posts/mosn-extensions/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/blog/posts/mosn-extensions/1586436269068-a0a77749-1a98-4bce-9e9b-323ea3bd14a5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;plugin机制&#34;&gt;Plugin机制&lt;/h4&gt;
&lt;p&gt;MOSN 的 Plugin 机制包含了两部分内容，一是 MOSN 自定义的 Plugin 框架，它支持通过在 MOSN 中实现 agent 与一个独立的进程进行交互来完成 MOSN 扩展能力的实现。二是基于 Golang 的 Plugin 框架，通过动态库（SO）加载的方式，实现 MOSN 的扩展。其中动态库加载的方式目前还存在一些局限性，还处于 beta 阶段。&lt;/p&gt;
&lt;h4 id=&#34;多进程-plugin-框架&#34;&gt;多进程 Plugin 框架&lt;/h4&gt;
&lt;p&gt;MOSN 的 Plugin 框架是 MOSN 封装的一个可以让 MOSN 通过 gRPC 和独立进程进行交互的方式，它包含两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立的进程通过 MOSN Plugin 框架管理，作为 MOSN 的子进程；MOSN 的 Plugin 框架可以管理它们，如启动、关闭等；&lt;/li&gt;
&lt;li&gt;通过在 MOSN 中实现的 agent，使用 gRPC 的方式和子进程进行交互，gRPC 可以是基于 tcp 的，也可以是基于 domain socket 的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/blog/posts/mosn-extensions/1586436268954-38e37509-fbf8-44f4-a0fe-0860401daae0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;二mosn-vs-envoy&#34;&gt;二、Mosn VS Envoy&lt;/h2&gt;
&lt;h3 id=&#34;amosn-与-envoy-不同点是什么优势在哪里&#34;&gt;A、MOSN 与 Envoy 不同点是什么？优势在哪里？&lt;/h3&gt;
&lt;h4 id=&#34;语言栈的不同&#34;&gt;语言栈的不同&lt;/h4&gt;
&lt;p&gt;MOSN 使用 Go 语言编写，Go 语言在生产效率，内存安全上有比较强的保障，同时 Go 语言在云原生时代有广泛的库生态系统，性能在 Mesh 场景下被我们评估以及实践是可以接受的。所以 MOSN 对于使用 Go、Java 等语言的公司和个人的心智成本更低。&lt;/p&gt;
&lt;h4 id=&#34;核心能力的差异化&#34;&gt;核心能力的差异化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MOSN 支持多协议框架，用户可以比较容易的接入私有协议，具有统一的路由框架；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多进程的插件机制，可以通过插件框架很方便的扩展独立 MOSN 进程的插件，做一些其他管理，旁路等的功能模块扩展；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具备中国密码合规的传输层国密算法支持；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;三webassembly&#34;&gt;三、WebAssembly&lt;/h2&gt;
&lt;p&gt;采用 WebAssembly(Wasm) 技术，给 MOSN 实现了一个安全隔离的沙箱环境，让扩展程序能够运行在隔离沙箱之中，并对其资源、能力进行严格限制，使程序故障止步于沙箱，从而实现安全隔离的目标。本文将着重叙述 MOSN 中的 Wasm 扩展框架，并介绍我们在 Proxy-Wasm 这一代理扩展规范上的工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/blog/posts/mosn-wasm-framework/framework.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图为 MOSN Wasm 扩展框架的整体示意图。如图所示，对于 MOSN 的任意扩展点(Codec、NetworkFilter、StreamFilter 等)，用户均能够通过 Wasm 扩展框架，以隔离沙箱的形式运行自定义的扩展代码。而 MOSN 与 Wasm 扩展代码之间的交互，是通过 Proxy-Wasm 标准 ABI 来完成的。&lt;/p&gt;
&lt;h4 id=&#34;隔离沙箱&#34;&gt;隔离沙箱&lt;/h4&gt;
&lt;p&gt;当我们在讨论 Wasm 时，都明白 Wasm 能够提供一个安全隔离的沙箱环境，但并不是每个人都了解 Wasm 实现隔离沙箱的技术原理。这时又要搬出计算机科学中的至理名言: “计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”。Wasm 实际上也是通过引用一个“中间层”来实现的安全隔离。简单来说，Wasm 通过一个运行时(Runtime)来运行 Wasm 沙箱扩展，每个 Wasm 沙箱都有其独立的线性内存空间和一组导入/导出模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/blog/posts/mosn-wasm-framework/wasm-memory.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;一方面，每个 Wasm 沙箱都有其独立的线性内存空间，其内存模型如上图所示。Wasm 代码只能通过简单的 load/store 等指令访问线性内存空间的有限部分，并通过符号(下标)的方式来间接访问函数、全局变量等，杜绝了类似 C 语言中访问任意内存地址的骚操作。同时，用于间接调用函数的符号表对于 Wasm 代码而言是只读的，从而保证 Wasm 代码的执行是受控的。此外，Wasm 沙箱的整个线性内存空间由宿主机(Wasm Runtime)分配及管理，通过严格的内存管理保证沙箱的隔离性。&lt;/p&gt;
&lt;p&gt;另一方面，Wasm 也规定了代码中任何可能产生外部影响的操作只能通过导入/导出模块来实现。以 C 语言为例，我们可以直接通过系统调用来访问系统的环境变量、文件、网络等资源。而在 Wasm 的世界中，并不存在系统调用相关的指令，任何对外部资源的访问必须通过导入模块来间接实现。以文件读写为例，在 Wasm 中要想进行文件读写，需要宿主机提供实现文件读写功能的导入函数，Wasm 代码调用该导入函数，由宿主机间接进行文件读写，再将操作结果返回给 Wasm 扩展。在上述过程中，实际的文件读写操作由宿主机完成，宿主机对这一过程有绝对的控制权，包括但不限于只允许读写指定文件、限制读写内容、完全禁止读写等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mosn.io/blog/posts/mosn-wasm-framework/config.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;proxy-wasm-abi-规范&#34;&gt;Proxy-Wasm ABI 规范&lt;/h4&gt;
&lt;p&gt;本小节将介绍 MOSN 具体是如何跟 Wasm 扩展程序进行交互的。先说结论: MOSN 跟 Wasm 扩展代码之间的交互采用的是社区规范: Proxy-Wasm&lt;/p&gt;
&lt;p&gt;Proxy-Wasm 规范定义了宿主机与 Wasm 扩展程序之间的交互细节，包括 API 列表、函数调用规范以及数据传输规范这几个方面。其中，API 列表包含了 L4/L7、property、metrics、日志等方面的扩展点，涵盖了网络代理场景下所需的大部分交互点，且可以划分为宿主侧扩展和 Wasm 侧扩展点。这里简单展示规范中的部分内容，完整内容请参考 spec。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Netty Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/20/netty-landscape/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/20/netty-landscape/</guid>
      <description>
        
        
        &lt;h3 id=&#34;参考文章&#34;&gt;参考文章&lt;/h3&gt;
&lt;h4 id=&#34;io-模型&#34;&gt;IO 模型&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://xie.infoq.cn/article/25d369e183563e44fc50d8168&#34;&gt;https://xie.infoq.cn/article/25d369e183563e44fc50d8168&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Reactive Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/20/reactive-landscape/</link>
      <pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/20/reactive-landscape/</guid>
      <description>
        
        
        &lt;h3 id=&#34;参考文章&#34;&gt;参考文章&lt;/h3&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Envoy Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/05/03/envoy-landscape/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/05/03/envoy-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;一envoy-常用概念&#34;&gt;一、Envoy 常用概念&lt;/h2&gt;
&lt;h3 id=&#34;alistener-监听器&#34;&gt;A、Listener 监听器&lt;/h3&gt;
&lt;h4 id=&#34;dns-过滤器&#34;&gt;DNS 过滤器&lt;/h4&gt;
&lt;p&gt;Envoy 支持通过配置UDP 侦听器 DNS Filter来响应 DNS 请求。&lt;/p&gt;
&lt;p&gt;DNS 过滤器支持响应 A 和 AAAA 记录的转发查询。答案是从静态配置的资源、集群或外部 DNS 服务器中发现的。过滤器将返回最多 512 个字节的 DNS 响应。如果域配置了多个地址，或者集群配置了多个端点，Envoy
将返回每个发现的地址，但不超过上述大小限制。&lt;/p&gt;
&lt;h3 id=&#34;bhttp-相关&#34;&gt;B、HTTP 相关&lt;/h3&gt;
&lt;h4 id=&#34;envoy-http重定向&#34;&gt;envoy http重定向&lt;/h4&gt;
&lt;p&gt;配置http过滤器类型为envoy.filters.http.router，我们的用例中需要这个过滤器将地址127.0.0.1:10000上收到的请求路由到www.envoyproxy.io，
除此之外，envoy还有其他过滤器，比如带宽限制过滤器envoy.filters.http.bandwidth_limit,速率限制过滤器envoy.filters.http.ratelimit等。具体可参考：http 过滤器。&lt;/p&gt;
&lt;p&gt;指定了cluster的名称为service_envoyproxy_io，
上文中的listener监听到的请求在37行就会被路由到该cluster，listener_0监听来自下游主机的请求后，路由到service_envoyproxy_io，service_envoyproxy_io会将该请求发送给相应的上游端点进行处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ciocso.com/article/730.html&#34;&gt;https://www.ciocso.com/article/730.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;路线匹配&#34;&gt;路线匹配&lt;/h4&gt;
&lt;p&gt;当 Envoy 匹配路由时，它使用以下过程：&lt;/p&gt;
&lt;p&gt;HTTP 请求的主机或:authority标头与虚拟主机匹配。&lt;/p&gt;
&lt;p&gt;按顺序检查虚拟主机中的 每个路由条目。如果存在匹配，则使用该路由并且不再进行路由检查。&lt;/p&gt;
&lt;p&gt;独立地，按顺序检查虚拟主机中的每个虚拟集群。如果匹配，则使用虚拟集群并且不再进行虚拟集群检查。&lt;/p&gt;
&lt;h4 id=&#34;http-动态转发代理&#34;&gt;HTTP 动态转发代理&lt;/h4&gt;
&lt;p&gt;通过HTTP 过滤器和 自定义集群的组合，Envoy 支持 HTTP 动态转发代理。这意味着 Envoy 可以在不事先了解所有配置的 DNS 地址的情况下执行 HTTP 代理的角色，同时仍保留 Envoy 的绝大多数优势，包括异步 DNS
解析。实施工作如下：&lt;/p&gt;
&lt;p&gt;如果目标 DNS 主机尚未在缓存中，则动态转发代理 HTTP 过滤器用于暂停请求。&lt;/p&gt;
&lt;p&gt;Envoy 将开始异步解析 DNS 地址，并在解析完成时解锁任何等待响应的请求。&lt;/p&gt;
&lt;p&gt;由于 DNS 地址已在缓存中，因此不会阻止任何未来的请求。解析过程类似于逻辑 DNS服务发现类型，在任何给定时间都会记住一个目标地址。&lt;/p&gt;
&lt;p&gt;所有已知主机都存储在动态转发代理集群中，以便它们可以显示在管理输出中。&lt;/p&gt;
&lt;p&gt;一个特殊的负载均衡器将在转发期间根据 HTTP 主机/权限标头选择要使用的正确主机。&lt;/p&gt;
&lt;p&gt;一段时间未使用的主机会受到将清除它们的 TTL。&lt;/p&gt;
&lt;p&gt;当上游集群配置了 TLS 上下文时，Envoy 将自动对解析的主机名执行 SAN 验证，并通过 SNI 指定主机名。&lt;/p&gt;
&lt;p&gt;上述实现细节意味着在稳定状态下，Envoy 可以转发大量 HTTP 代理流量，而所有 DNS 解析都在后台异步进行。此外，所有其他 Envoy 过滤器和扩展都可以与动态转发代理支持结合使用，包括身份验证、RBAC、速率限制等 。&lt;/p&gt;
&lt;h4 id=&#34;http-标头&#34;&gt;HTTP 标头&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers&#34;&gt;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;http-过滤器&#34;&gt;HTTP 过滤器&lt;/h4&gt;
&lt;p&gt;动态代理转发&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/dynamic_forward_proxy_filter&#34;&gt;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/dynamic_forward_proxy_filter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;c服务发现&#34;&gt;C、服务发现&lt;/h3&gt;
&lt;h4 id=&#34;原始目的地&#34;&gt;原始目的地&lt;/h4&gt;
&lt;p&gt;当传入连接通过 iptables REDIRECT 或 TPROXY 目标或使用代理协议重定向到 Envoy
时，可以使用原始目标集群。在这些情况下，路由到原始目标集群的请求被转发到由重定向元数据寻址的上游主机，而无需任何显式主机配置或上游主机发现。当上游主机的空闲时间超过 cleanup_interval（默认为 5000
毫秒）时，连接到上游主机的连接被池化，并且未使用的主机被刷新。如果原始目标地址不可用，则不打开上游连接。Envoy 还可以从HTTP 标头中获取原始目标。原始目标服务发现必须与原始目标负载均衡器一起使用.&lt;/p&gt;
&lt;h4 id=&#34;原始来源&#34;&gt;原始来源&lt;/h4&gt;
&lt;p&gt;此过滤器应配置为envoy.filters.listener.original_src名称。&lt;/p&gt;
&lt;p&gt;原始源侦听器过滤器在 Envoy 的上游端复制连接的下游远程地址。例如，如果下游连接使用 IP 地址连接到 Envoy 10.1.2.3，那么 Envoy 将使用源 IP 连接到上游10.1.2.3。&lt;/p&gt;
&lt;h3 id=&#34;d热重启&#34;&gt;D、热重启&lt;/h3&gt;
&lt;p&gt;易于操作是 Envoy 的主要目标之一。除了强大的统计数据和本地管理界面之外，Envoy 还能够“热”或“实时”重启自身。这意味着 Envoy 可以完全重新加载自身（代码和配置），而不会在排水过程中丢弃现有连接。热重启功能具有以下通用架构：&lt;/p&gt;
&lt;p&gt;两个活动进程使用基本的 RPC 协议通过 unix 域套接字相互通信。所有计数器都通过 unix 域从旧进程发送到新进程，并且除了标有NeverImport的那些之外，还会传输仪表。热重启完成后，从旧进程传来的 gauge 会被清理，但
会保留server.hot_restart_generation 统计等特殊的 gauge 。&lt;/p&gt;
&lt;p&gt;新进程在向旧进程请求侦听套接字的副本之前，会完全初始化自身（加载配置、执行初始服务发现和健康检查阶段等）。新进程开始监听，然后告诉旧进程开始排空。&lt;/p&gt;
&lt;p&gt;在耗尽阶段，旧进程尝试正常关闭现有连接。如何完成取决于配置的过滤器。排水时间可通过 &amp;ndash;drain-time-s选项配置，随着时间的推移，排水变得更加激进。&lt;/p&gt;
&lt;p&gt;在耗尽序列之后，新的 Envoy 进程告诉旧的 Envoy 进程自行关闭。该时间可通过&amp;ndash;parent-shutdown-time-s选项进行配置。&lt;/p&gt;
&lt;p&gt;Envoy 的热重启支持被设计为即使新的 Envoy 进程和旧的 Envoy 进程在不同的容器中运行，它也能正常工作。进程之间的通信仅使用 unix 域套接字进行。&lt;/p&gt;
&lt;p&gt;源代码分发中包含一个用 Python 编写的示例重启程序/父进程。此父进程可用于标准进程控制实用程序，例如 monit/runit/etc。&lt;/p&gt;
&lt;h3 id=&#34;eip-相关&#34;&gt;E、IP 相关&lt;/h3&gt;
&lt;h4 id=&#34;http-标头-1&#34;&gt;HTTP 标头&lt;/h4&gt;
&lt;p&gt;HTTP 标头可以在x-forwarded-for标头中携带请求的原始 IP 地址 。上游服务器可以使用此标头来确定下游远程地址。Envoy 也可以使用这个 header 来选择 Original Src HTTP Filter使用的 IP
地址。&lt;/p&gt;
&lt;p&gt;HTTP 标头方法有一些缺点：&lt;/p&gt;
&lt;p&gt;它仅适用于 HTTP。&lt;/p&gt;
&lt;p&gt;上游主机可能不支持它。&lt;/p&gt;
&lt;p&gt;它需要仔细配置。&lt;/p&gt;
&lt;h3 id=&#34;f生命周期&#34;&gt;F、生命周期&lt;/h3&gt;
&lt;h4 id=&#34;术语&#34;&gt;术语&lt;/h4&gt;
&lt;p&gt;Envoy 在其代码库和文档中使用以下术语：&lt;/p&gt;
&lt;p&gt;集群：具有一组端点的逻辑服务，Envoy 将请求转发到这些端点。&lt;/p&gt;
&lt;p&gt;下游：连接到 Envoy 的实体。这可能是本地应用程序（在边车模型中）或网络节点。在非 Sidecar 模型中，这是一个远程客户端。&lt;/p&gt;
&lt;p&gt;端点：实现逻辑服务的网络节点。它们被分组到集群中。集群中的端点位于Envoy 代理的上游。&lt;/p&gt;
&lt;p&gt;过滤器：连接或请求处理管道中的模块，提供请求处理的某些方面。Unix 的一个类比是小型实用程序（过滤器）与 Unix 管道（过滤器链）的组合。&lt;/p&gt;
&lt;p&gt;过滤器链：一系列过滤器。&lt;/p&gt;
&lt;p&gt;侦听器：Envoy 模块，负责绑定到 IP/端口、接受新的 TCP 连接（或 UDP 数据报）并协调面向下游的请求处理方面。&lt;/p&gt;
&lt;p&gt;上游：Envoy 在转发服务请求时连接的端点（网络节点）。这可能是本地应用程序（在边车模型中）或网络节点。在非边车模型中，这对应于远程后端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/envoy/envoy-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;二envoy-启动流程&#34;&gt;二、Envoy 启动流程&lt;/h2&gt;
&lt;h4 id=&#34;envoy-完整配置&#34;&gt;Envoy 完整配置&lt;/h4&gt;
&lt;p&gt;从 Envoy 初始化配置文件中，我们可以看出 Istio 中 Envoy sidecar 真正的配置实际上是由两部分组成的。Pilot-agent 在启动 Envoy 时将 xDS server 信息通过静态资源的方式配置到 Envoy
的初始化配置文件中，Envoy 启动后再通过 xDS server 获取网格中的服务信息、路由规则等动态资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.servicemesher.com/istio-handbook/images/envoy-config-init.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pilot-agent 根据启动参数生成 Envoy 的初始配置文件 envoy-rev0.json，该文件告诉 Envoy 从指定的 xDS server 中获取动态配置信息，并配置了 xDS server 的地址信息，即控制平面的
Pilot 服务器地址。&lt;/li&gt;
&lt;li&gt;Pilot-agent 使用 envoy-rev0.json 启动 Envoy 进程。&lt;/li&gt;
&lt;li&gt;Envoy 根据初始配置获得 Pilot 地址，采用 xDS 接口从 Pilot 获取到 listener，cluster，route 等动态配置信息。&lt;/li&gt;
&lt;li&gt;Envoy 根据获取到的动态配置启动 Listener，并根据 listener 的配置，结合 route 和 cluster 对拦截到的流量进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;二envoy-流量&#34;&gt;二、Envoy 流量&lt;/h2&gt;
&lt;h3 id=&#34;a流量路由机制分析&#34;&gt;A、流量路由机制分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;重要参考资料！！！：https://www.servicemesher.com/istio-handbook/concepts/sidecar-traffic-route.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;术语-1&#34;&gt;术语&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Host： 能够进行网络通信的实体（如移动设备、服务器上的应用程序）。在此文档中，host 是一个逻辑上的网络应用程序。一个物理硬件上可能运行有多个 host，只要它们是可以独立寻址的。在 EDS 接口中，也使用 “endpoint”
来表示一个应用实例，对应一个 IP + port 的组合。&lt;/li&gt;
&lt;li&gt;Downstream： 下游 host 连接到 Envoy，发送请求并接收响应。&lt;/li&gt;
&lt;li&gt;Upstream： 上游 host 接收来自 Envoy 的连接和请求，并返回响应。&lt;/li&gt;
&lt;li&gt;Listener： 监听器是一个命名网络地址（例如，端口、unix domain socket 等)，可以被下游客户端连接。Envoy 中暴露一个或者多个给下游主机连接的监听器。在 Envoy 中，&lt;strong&gt;listener
可以绑定到端口上直接对外提供服务，也可以不绑定到端口上，而是接收其他 listener 转发的请求。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Cluster： 集群是指 Envoy 连接的一组上游主机，集群中的主机是对等的，对外提供相同的服务，这些主机一起组成了一个可以提供负载均衡和高可用的服务集群。Envoy
通过服务发现来发现集群的成员。可以选择通过主动健康检查来确定集群成员的健康状态。Envoy 通过负载均衡策略决定将请求路由到哪个集群成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;listeners&#34;&gt;Listeners&lt;/h3&gt;
&lt;p&gt;Envoy 采用 listener 来接收并处理 downstream 发过来的请求，listener 采用了插件式的架构，可以通过配置不同的 filter 在 listener 中插入不同的处理逻辑。&lt;/p&gt;
&lt;p&gt;Listener 可以绑定到 IP Socket 或者 Unix Domain Socket 上，以接收来自客户端的请求；也可以不绑定，而是接收从其他 listener 转发来的数据。Istio 利用了 Envoy listener
的这一特点，通过 VirtualOutboundListener 在一个端口接收所有出向请求，然后再按照请求的端口分别转发给不同的 listener 分别处理。&lt;/p&gt;
&lt;h4 id=&#34;virtualoutbound-listener&#34;&gt;VirtualOutbound Listener&lt;/h4&gt;
&lt;p&gt;Istio 在 Envoy 中配置了一个在 15001 端口监听的虚拟入口监听器。Iptable 规则将 Envoy 所在 pod 的对外请求拦截后发向本地的 15001
端口，该监听器接收后并不进行业务处理，而是根据请求的目的端口分发给其他监听器处理。这就是该监听器取名为 &amp;ldquo;virtual”（虚拟）监听器的原因。&lt;/p&gt;
&lt;p&gt;Envoy 是如何做到按请求的目的端口进行分发的呢？ 从下面 VirtualOutbound listener 的配置中可以看到 use_original_dest 属性被设置为 true, 这表示该&lt;strong&gt;监听器在接收到来自
downstream 的请求后，会将请求转交给匹配该请求原目的地址的 listener（即名字格式为 0.0.0.0_ 请求目的端口 的 listener）进行处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在 Enovy 的配置中找不到匹配请求目的端口的 listener，则将会根据 Istio 的 outboundTrafficPolicy 全局配置选项进行处理。存在两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 outboundTrafficPolicy 设置为 &lt;strong&gt;ALLOW_ANY&lt;/strong&gt;：这表明网格允许发向任何外部服务的请求，无论该服务是否在 Pilot 的服务注册表中。在该策略下，Pilot 将会在下发给 Envoy 的
VirtualOutbound listener 加入一个 upstream cluster 为 &lt;code&gt;PassthroughCluster&lt;/code&gt; 的 TCP proxy filter，找不到匹配端口 listener 的请求会被该 TCP
proxy filter 处理，&lt;strong&gt;请求将会被发送到其 IP 头中的原始目的地地址。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 outboundTrafficPolicy 设置为 &lt;strong&gt;REGISTRY_ONLY&lt;/strong&gt;：只允许发向 Pilot 服务注册表中存在的服务的对外请求。在该策略下，Pilot 将会在下发给 Enovy 的 VirtualOutbound
listener 加入一个 upstream cluster 为 BlackHoleCluster 的 TCP proxy filter，找不到匹配端口 listener 的请求会被该 TCP proxy filter 处理，由于
BlackHoleCluster 中没有配置 upstteam host，请求实际上会被丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图是 bookinfo 例子中 productpage 服务中 Enovy Proxy 的 Virutal Outbound Listener 配置。由于 outboundTrafficPolicy 的默认配置为 ALLOW_ANY，因此
listener 的 filterchain 中第二个 filter chain 中是一个 upstream cluster 为 PassthroughCluster 的 TCP proxy filter。注意该 filter 没有
filter_chain_match 匹配条件，因此如果进入该 listener 的请求在配置中找不到匹配其目的端口的 listener，就会缺省进入该 filter 进行处理。&lt;/p&gt;
&lt;p&gt;filterchain 中的第一个 filter chain 中是一个 upstream cluster 为 BlackHoleCluster 的 TCP proxy filter，该 filter 设置了
filter_chain_match 匹配条件，只有发向 10.40.0.18 这个 IP 的出向请求才会进入该 filter 处理。10.40.0.18 是 productpage 服务自身的IP地址。该 filter
的目的是为了防止服务向自己发送请求可能导致的死循环。&lt;/p&gt;
&lt;h5 id=&#34;passthroughcluster&#34;&gt;PassthroughCluster&lt;/h5&gt;
&lt;p&gt;该 cluster 的 type 被设置为 ORIGINAL_DST 类型， 表明任何发向该 cluster 的请求都会被直接发送到其请求中的原始目地的，Envoy 不会对请求进行重新路由。&lt;/p&gt;
&lt;h5 id=&#34;blackholecluster&#34;&gt;BlackHoleCluster&lt;/h5&gt;
&lt;p&gt;这是一个特殊的 cluster ，其中并没有配置后端处理请求的 host。如其名字所表明的一样，请求进入该 cluster 后如同进入了一个黑洞，将被丢弃掉，而不是发向一个 upstream host。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;三envoy-运维&#34;&gt;三、Envoy 运维&lt;/h2&gt;
&lt;h4 id=&#34;管理界面&#34;&gt;管理界面&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/operations/admin&#34;&gt;https://www.envoyproxy.io/docs/envoy/latest/operations/admin&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;查看配置&#34;&gt;查看配置&lt;/h3&gt;
&lt;p&gt;可以看到，Envoy 中实际生效的配置是由初始化配置文件中的静态配置和从 Pilot 获取的动态配置一起组成的。因此只对 envoy-rev0 .json 进行分析并不能看到网络中流量管理的全貌。那么有没有办法可以看到 Envoy
中实际生效的完整配置呢？Envoy 提供了相应的管理接口，我们可以采用下面的命令导出 productpage-v1 服务 sidecar 的完整配置。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubectl exec -it productpage-v1-6d8bc58dd7-ts8kw -c istio-proxy curl http://127.0.0.1:15000/config_dump &amp;gt; config_dump
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该配置文件的内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;configs&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.admin.v3.BootstrapConfigDump&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;bootstrap&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{},&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;last_updated&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2020-03-11T08:14:03.630Z&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.admin.v3.ClustersConfigDump&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;version_info&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2020-03-11T08:14:06Z/23&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;static_clusters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;dynamic_active_clusters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.admin.v3.ListenersConfigDump&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;version_info&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2020-03-11T08:13:39Z/22&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;static_listeners&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;dynamic_listeners&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.admin.v3.RoutesConfigDump&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;static_route_configs&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;dynamic_route_configs&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.admin.v3.SecretsConfigDump&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;dynamic_active_secrets&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从导出的文件中可以看到 Envoy 中主要由以下几部分内容组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BootstrapConfigDump： 初始化配置，来自于初始化配置文件中配置的内容。&lt;/li&gt;
&lt;li&gt;ClustersConfigDump： 集群配置，包括对应于外部服务的 outbound cluster 和 自身所在节点服务的 inbound cluster。&lt;/li&gt;
&lt;li&gt;ListenersConfigDump： 监听器配置，包括用于处理对外业务请求的 outbound listener，处理入向业务请求的 inbound listener，以及作为流量处理入口的 virtual listener。&lt;/li&gt;
&lt;li&gt;RoutesConfigDump： 路由配置，用于 HTTP 请求的路由处理。&lt;/li&gt;
&lt;li&gt;SecretsConfigDump： TLS 双向认证相关的配置，包括自身的证书以及用于验证请求方的 CA 根证书。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们对该配置文件中和流量路由相关的配置一一进行详细分析。&lt;/p&gt;
&lt;h4 id=&#34;bootstrap&#34;&gt;Bootstrap&lt;/h4&gt;
&lt;p&gt;从名字可以看出这是 Envoy 的初始化配置，打开该节点，可以看到其中的内容和 envoy-rev0.json 是一致的，这里不再赘述。 需要注意的是在 bootstrap 部分配置的一些内容也会被用于其他部分，例如 clusters
部分就包含了 bootstrap 中定义的一些静态 cluster 资源。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.admin.v3.BootstrapConfigDump&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;bootstrap&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;node&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;stats_config&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;admin&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;dynamic_resources&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;static_resources&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;tracing&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#a40000&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;last_updated&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2020-03-11T08:14:03.630Z&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;clusters&#34;&gt;Clusters&lt;/h4&gt;
&lt;p&gt;这部分配置定义了 Envoy 中所有的 cluster，即服务集群，cluster 中包含一个到多个 endpoint，每个 endpoint 都可以提供服务，Envoy 根据负载均衡算法将请求发送到这些 endpoint 中。&lt;/p&gt;
&lt;p&gt;从配置文件结构中可以看到，在 productpage 的 clusters 配置中包含 static_clusters 和 dynamic_active_clusters 两部分，其中 static_clusters 是来自于
envoy-rev0.json 的初始化配置中的 prometheus_stats、xDS server、zipkin server 信息。dynamic_active_clusters 是 Envoy 通过 xDS 接口从 Istio
控制平面获取的服务信息。&lt;/p&gt;
&lt;p&gt;其中 dynamic cluster 又分为以下几类：&lt;/p&gt;
&lt;h5 id=&#34;outbound-cluster&#34;&gt;Outbound Cluster&lt;/h5&gt;
&lt;p&gt;这部分的 cluster 占了绝大多数，该类 cluster 对应于 Envoy 所在节点的外部服务。以 reviews 为例，对于 productpage 来说，reviews 是一个外部服务，因此其 cluster 名称中包含
outbound 字样。&lt;/p&gt;
&lt;p&gt;从 reviews 服务对应的 cluster 配置中可以看到，其类型为 EDS，即表示该 cluster 的 endpoint 来自于动态发现，动态发现中 eds_config 则指向了ads，最终指向 static resource
中配置的 xds-grpc cluster，即 Pilot 的地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;version_info&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2020-03-11T08:13:39Z/22&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;cluster&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;@type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;type.googleapis.com/envoy.api.v2.Cluster&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;outbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;EDS&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;eds_cluster_config&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;eds_config&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;ads&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{}&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;service_name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;outbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;connect_timeout&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;1s&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;circuit_breakers&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{},&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;filters&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[],&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;transport_socket_matches&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[]&lt;/span&gt;
  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;last_updated&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2020-03-11T08:14:04.664Z&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以通过 Pilot 的调试接口获取该 cluster 的 endpoint：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://10.97.222.108:15014/debug/edsz &amp;gt; pilot_eds_dump
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从导出的文件内容可以看到，reviews cluster 配置了3个 endpoint 地址，是 reviews 的 pod ip。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;clusterName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;outbound|9080||reviews.default.svc.cluster.local&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
  &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;endpoints&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;lbEndpoints&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;endpoint&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
              &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;10.40.0.15&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;9080&lt;/span&gt;
              &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
          &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{},&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;loadBalancingWeight&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;endpoint&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
              &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;10.40.0.16&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;9080&lt;/span&gt;
              &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
          &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{},&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;loadBalancingWeight&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;endpoint&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
              &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;socketAddress&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;address&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;10.40.0.17&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
                &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;portValue&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;9080&lt;/span&gt;
              &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
          &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;},&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;metadata&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{},&lt;/span&gt;
          &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;loadBalancingWeight&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
      &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;],&lt;/span&gt;
      &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;#34;loadBalancingWeight&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;3&lt;/span&gt;
    &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;inbound-cluster&#34;&gt;Inbound Cluster&lt;/h5&gt;
&lt;p&gt;对于 Envoy 来说，inbound cluster 对应于入向请求的 upstream 集群， 即 Envoy 自身所在节点的服务。对于 productpage Pod 上的 Envoy，其对应的 Inbound cluster 只有一个，即 productpage。该 cluster 对应的 host 为127.0.0.1，即回环地址上 productpage 的监听端口。由于 iptable 规则中排除了127.0.0.1，入站请求通过该 Inbound cluster 处理后将跳过 Envoy，直接发送给 productpage 进程处理。&lt;/p&gt;
&lt;h5 id=&#34;blackholecluster-1&#34;&gt;BlackHoleCluster&lt;/h5&gt;
&lt;h5 id=&#34;passthroughcluster-1&#34;&gt;PassthroughCluster&lt;/h5&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Istio devops</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/03/09/istio-devops/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/03/09/istio-devops/</guid>
      <description>
        
        
        &lt;h3 id=&#34;请求的生命周期&#34;&gt;请求的生命周期&lt;/h3&gt;
&lt;p&gt;在这些示例中，我们将介绍应用程序运行时会发生什么curl example.com。虽然在curl这里使用，但同样适用于几乎所有客户端。&lt;/p&gt;
&lt;p&gt;当您向域发送请求时，客户端将执行 DNS 解析以将其解析为 IP 地址。无论 Istio 设置如何，都会发生这种情况，因为 Istio 只拦截网络流量；它不能改变您的应用程序的行为或发送 DNS 请求的决定。在下面的示例中，example.com解析为192.0.2.0.&lt;/p&gt;
&lt;p&gt;$ curl example.com -v&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trying 192.0.2.0:80&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，请求将被 Istio 拦截。此时，Istio 将同时看到主机名（来自Host: example.com标头）和目标地址 ( 192.0.2.0:80)。Istio 使用此信息来确定预期目的地。 了解流量路由可以深入了解此行为的工作原理。&lt;/p&gt;
&lt;p&gt;如果客户端无法解析 DNS 请求，请求将在 Istio 收到之前终止。这意味着如果将请求发送到 Istio 已知的主机名（例如 a VirtualService）但不发送到 DNS 服务器，则请求将失败。Istio DNS 代理可以改变这种行为。&lt;/p&gt;
&lt;p&gt;一旦 Istio 确定了预期的目的地，它必须选择要发送到的地址。由于 Istio 的高级负载均衡功能，这通常不是客户端发送的原始 IP 地址。根据服务配置，Istio 有几种不同的方式来执行此操作。&lt;/p&gt;
&lt;p&gt;使用客户端的原始 IP 地址（192.0.2.0在上面的示例中）。这是ServiceEntrytype resolution: NONE（默认）和headlessServices的情况。
在一组静态 IP 地址上进行负载平衡。这是ServiceEntrytype的情况，将使用resolution: STATICall ，或 standard ，将使用 all 。spec.endpointsServicesEndpoints
使用 DNS 定期解析地址，并对所有结果进行负载平衡。这是ServiceEntrytype的情况resolution: DNS。
请注意，在所有情况下，Istio 代理中的 DNS 解析都与用户应用程序中的 DNS 解析正交。即使客户端进行 DNS 解析，代理也可能会忽略解析的 IP 地址并使用自己的 IP 地址，这可能来自静态 IP 列表或通过自己的 DNS 解析（可能是相同的主机名或不同的主机名）。&lt;/p&gt;
&lt;p&gt;DNS 代理
3分钟阅读 页面测试&lt;/p&gt;
&lt;p&gt;除了捕获应用程序流量之外，Istio 还可以捕获 DNS 请求以提高网格的性能和可用性。在代理 DNS 时，来自应用程序的所有 DNS 请求都将被重定向到 sidecar，其中存储了本地域名到 IP 地址的映射。如果请求可以被 Sidecar 处理，它将直接向应用程序返回响应，避免往返上游 DNS 服务器。否则，请求将按照标准/etc/resolv.confDNS 配置向上游转发。&lt;/p&gt;
&lt;p&gt;虽然 Kubernetes 为 Kubernetes 提供了开箱即用的 DNS 解析Service，但任何自定义ServiceEntry的都不会被识别。使用此功能，ServiceEntry无需自定义配置 DNS 服务器即可解析地址。对于 Kubernetes Service，DNS 响应将是相同的，但负载减少kube-dns并提高了性能。&lt;/p&gt;
&lt;p&gt;此功能也可用于在 Kubernetes 之外运行的服务。这意味着可以解决所有内部服务，而无需笨拙的变通方法将 Kubernetes DNS 条目暴露在集群之外。&lt;/p&gt;
&lt;p&gt;入门
默认情况下当前未启用此功能。要启用它，请使用以下设置安装 Istio：&lt;/p&gt;
&lt;p&gt;$ cat &amp;laquo;EOF | istioctl install -y -f -
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
meshConfig:
defaultConfig:
proxyMetadata:&lt;/p&gt;
&lt;h1 id=&#34;enable-basic-dns-proxying&#34;&gt;Enable basic DNS proxying&lt;/h1&gt;
&lt;p&gt;ISTIO_META_DNS_CAPTURE: &amp;ldquo;true&amp;rdquo;&lt;/p&gt;
&lt;h1 id=&#34;enable-automatic-address-allocation-optional&#34;&gt;Enable automatic address allocation, optional&lt;/h1&gt;
&lt;p&gt;ISTIO_META_DNS_AUTO_ALLOCATE: &amp;ldquo;true&amp;rdquo;
EOF&lt;/p&gt;
&lt;p&gt;这也可以使用proxy.istio.io/configannotation在每个 pod 的基础上启用。&lt;/p&gt;
&lt;p&gt;使用 部署到 VM 时，默认情况下将启用基本 DNS 代理。istioctl workload entry configure
DNS 捕获在行动
要尝试 DNS 捕获，首先ServiceEntry为一些外部服务设置一个：&lt;/p&gt;
&lt;p&gt;apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
name: external-address
spec:
addresses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;198.51.100.0
hosts:&lt;/li&gt;
&lt;li&gt;address.internal
ports:&lt;/li&gt;
&lt;li&gt;name: http
number: 80
protocol: HTTP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有 DNS 捕获，请求address.internal可能无法解析。启用此功能后，您应该根据配置获得响应address：&lt;/p&gt;
&lt;p&gt;$ curl -v address.internal&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trying 198.51.100.1:80&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;地址自动分配
在上面的示例中，您有一个用于发送请求的服务的预定义 IP 地址。但是，访问没有稳定地址的外部服务是很常见的，而是依赖 DNS。在这种情况下，DNS 代理将没有足够的信息来返回响应，并且需要向上游转发 DNS 请求。&lt;/p&gt;
&lt;p&gt;这对于 TCP 流量来说尤其成问题。与基于Host标头路由的 HTTP 请求不同，TCP 携带的信息要少得多。您只能在目标 IP 和端口号上进行路由。因为后端没有一个稳定的IP，所以也不能基于它进行路由，只留下端口号，当多个ServiceEntryTCP服务共享同一个端口时，会导致冲突。&lt;/p&gt;
&lt;p&gt;为了解决这些问题，DNS 代理还支持为ServiceEntry未明确定义地址的 s 自动分配地址。这是由ISTIO_META_DNS_AUTO_ALLOCATE选项配置的。&lt;/p&gt;
&lt;p&gt;启用此功能后，DNS 响应将为每个ServiceEntry. 然后将代理配置为将请求匹配到此 IP 地址，并将请求转发到相应的ServiceEntry.&lt;/p&gt;
&lt;p&gt;由于此功能会修改 DNS 响应，因此它可能无法与所有应用程序兼容。
要尝试这一点，请配置另一个ServiceEntry：&lt;/p&gt;
&lt;p&gt;apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
name: external-auto
spec:
hosts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;auto.internal
ports:&lt;/li&gt;
&lt;li&gt;name: http
number: 80
protocol: HTTP
resolution: STATIC
endpoints:&lt;/li&gt;
&lt;li&gt;address: 198.51.100.2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，发送请求：&lt;/p&gt;
&lt;p&gt;$ curl -v auto.internal&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trying 240.240.0.1:80&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如您所见，请求被发送到一个自动分配的地址，240.240.0.1. 这些地址将从240.240.0.0/16保留的 IP 地址范围中挑选，以避免与实际服务发生冲突。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Istio Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/03/09/istio-landscape/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/03/09/istio-landscape/</guid>
      <description>
        
        
        &lt;blockquote&gt;
&lt;p&gt;参考文档：https://www.servicemesher.com/istio-handbook/concepts/sidecar-injection.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;一istio-sidecar&#34;&gt;一、Istio Sidecar&lt;/h2&gt;
&lt;h4 id=&#34;sidecar模式是什么&#34;&gt;Sidecar模式是什么&lt;/h4&gt;
&lt;p&gt;Sidecar模式是一种&lt;strong&gt;单节点、多容器&lt;/strong&gt;的应用设计形式。Sidecar主张以额外的容器来扩展或增强主容器,而这个额外的容器被称为Sidecar容器&lt;/p&gt;
&lt;p&gt;sidecar 模式也符合当前微服务的以下特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离(separation of concerns):让每个容器环境不需要相互依赖而独立运行,也就意味着sidecar程序可以和任何语言的应用服务一起运行。&lt;/li&gt;
&lt;li&gt;单一责任原则(single responsibility principle),各个容器负责自己的处理逻辑,各司其职&lt;/li&gt;
&lt;li&gt;内聚性/可重用性(Cohesiveness/Reusability)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.servicemesher.com/istio-handbook/images/sidecar-pattern.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;在软件架构中， Sidecar 连接到父应用并且为其添加扩展或者增强功能。Sidecar 应用与主应用程序松散耦合。它可以屏蔽不同编程语言的差异，统一实现微服务的可观察性、监控、日志记录、配置、断路器等功能。&lt;/p&gt;
&lt;h4 id=&#34;使用-sidecar-模式的优势&#34;&gt;使用 Sidecar 模式的优势&lt;/h4&gt;
&lt;p&gt;使用 sidecar 模式部署服务网格时，无需在节点上运行代理，但是集群中将运行多个相同的 sidecar 副本。在 sidecar 部署方式中，&lt;strong&gt;每个应用的容器旁都会部署一个伴生容器（如 Envoy 或 MOSN），这个容器称之为 sidecar 容器&lt;/strong&gt;。Sidecar 接管进出应用容器的所有流量。&lt;strong&gt;在 Kubernetes 的 Pod 中，在原有的应用容器旁边注入一个 Sidecar 容器，两个容器共享存储、网络等资源&lt;/strong&gt;，可以广义的将这个包含了 sidecar 容器的 Pod 理解为一台主机，两个容器共享主机资源。&lt;/p&gt;
&lt;p&gt;因其独特的部署结构，使得 sidecar 模式具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将与应用业务逻辑无关的功能抽象到共同基础设施，降低了微服务代码的复杂度。&lt;/li&gt;
&lt;li&gt;因为不再需要编写相同的第三方组件配置文件和代码，所以能够降低微服务架构中的代码重复度。
Sidecar 可独立升级，降低应用程序代码和底层平台的耦合度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sidecar模式&#34;&gt;Sidecar模式&lt;/h4&gt;
&lt;p&gt;借助于K8S良好的可拓展性，使用sidecar模式可以享受到分布式系统中的规模化效率红利。相比于这种效率提升，我们可以容许性能上的开销。&lt;/p&gt;
&lt;h3 id=&#34;sidecar实现&#34;&gt;Sidecar实现&lt;/h3&gt;
&lt;h4 id=&#34;该如何实现一个sidecar&#34;&gt;该如何实现一个sidecar&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在设计sidecar服务时,请慎重决定进程间通信机制。除非达不到性能要求,否则请尽量使用不区分语言或框架的技术。&lt;/li&gt;
&lt;li&gt;在将功能放入sidecar之前,请考虑该功能是作为独立的服务还是更传统的守护程序运行更有利。&lt;/li&gt;
&lt;li&gt;此外,请考虑是否能够以库的形式或使用传统扩展机制实现功能.特定于语言的库可能提供更深度的集成和更少的网络开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
	&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rootCmd&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Execute&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;();&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;nil&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;{&lt;/span&gt;
		&lt;span style=&#34;color:#000&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Error&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;err&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
		&lt;span style=&#34;color:#000&#34;&gt;os&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Exit&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
	&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;asidecar-vm&#34;&gt;A、Sidecar VM&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建虚拟机&lt;/li&gt;
&lt;li&gt;设置环境变量&lt;/li&gt;
&lt;li&gt;安装依赖包&lt;/li&gt;
&lt;li&gt;上传脚本到虚拟机&lt;/li&gt;
&lt;li&gt;命令行启动多个可执行文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bsidecar-docker&#34;&gt;B、Sidecar docker&lt;/h3&gt;
&lt;p&gt;借助 docker-compose.yml 文件，开发人员可定义一组相关服务，通过部署命令将其部署为组合应用程序。 它还配置其依赖项关系和运行时配置。多个容器使用同一个network。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dockerfile -&amp;gt; image&lt;/li&gt;
&lt;li&gt;imges      -&amp;gt; docker-compose&lt;/li&gt;
&lt;li&gt;docker-compose -&amp;gt; image&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://osswangxining.github.io/images/envoy-front-proxy-topology.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;version&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;3.4&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;services&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;webmvc&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;eshop/web&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;environment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;CatalogUrl=http://catalog-api&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;OrderingUrl=http://ordering-api&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ports&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;80:80&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;depends_on&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;catalog-api&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;ordering-api&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;catalog-api&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;eshop/catalog-api&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;environment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;ConnectionString=Server=sqldata;Port=1433;Database=CatalogDB;…&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ports&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;81:80&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;depends_on&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;sqldata&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ordering-api&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;eshop/ordering-api&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;environment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;ConnectionString=Server=sqldata;Database=OrderingDb;…&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ports&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;82:80&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;extra_hosts&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;CESARDLBOOKVHD:10.0.75.1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;depends_on&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;sqldata&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;sqldata&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;mcr.microsoft.com/mssql/server:latest&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;environment&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;SA_PASSWORD=Pass@word&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;ACCEPT_EULA=Y&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ports&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;5433:1433&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;istio-dockerfile&#34;&gt;istio dockerfile&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# BASE_DISTRIBUTION is used to switch between the old base distribution and distroless base images&lt;/span&gt;
ARG &lt;span style=&#34;color:#000&#34;&gt;BASE_DISTRIBUTION&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;debug

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Version is the base image version from the TLD Makefile&lt;/span&gt;
ARG &lt;span style=&#34;color:#000&#34;&gt;BASE_VERSION&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;latest

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# The following section is used as base image if BASE_DISTRIBUTION=debug&lt;/span&gt;
FROM gcr.io/istio-release/base:&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;BASE_VERSION&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt; as debug

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# The following section is used as base image if BASE_DISTRIBUTION=distroless&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# This image is a custom built debian11 distroless image with multiarchitecture support.&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# It is built on the base distroless image, with iptables binary and libraries added&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# The source can be found at https://github.com/istio/distroless/tree/iptables&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# This version is from commit 105e1319a176a5156205b9e351b4e2016363f00d.&lt;/span&gt;
FROM gcr.io/istio-release/iptables@sha256:bae9287d64be13179b7bc794ec3db26bd5c5fe3fb591c484992366314c9a7d3d as distroless

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# This will build the final image based on either debug or distroless from above&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# hadolint ignore=DL3006&lt;/span&gt;
FROM &lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;BASE_DISTRIBUTION&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;debug&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;

WORKDIR /

ARG proxy_version
ARG istio_version
ARG &lt;span style=&#34;color:#000&#34;&gt;SIDECAR&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;envoy

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Copy Envoy bootstrap templates used by pilot-agent&lt;/span&gt;
COPY envoy_bootstrap.json /var/lib/istio/envoy/envoy_bootstrap_tmpl.json
COPY gcp_envoy_bootstrap.json /var/lib/istio/envoy/gcp_envoy_bootstrap_tmpl.json

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Install Envoy.&lt;/span&gt;
ARG TARGETARCH
COPY &lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TARGETARCH&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;amd64&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;/&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SIDECAR&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt; /usr/local/bin/&lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SIDECAR&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Environment variable indicating the exact proxy sha - for debugging or version-specific configs &lt;/span&gt;
ENV ISTIO_META_ISTIO_PROXY_SHA &lt;span style=&#34;color:#000&#34;&gt;$proxy_version&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# Environment variable indicating the exact build, for debugging&lt;/span&gt;
ENV ISTIO_META_ISTIO_VERSION &lt;span style=&#34;color:#000&#34;&gt;$istio_version&lt;/span&gt;

ARG TARGETARCH
COPY &lt;span style=&#34;color:#4e9a06&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TARGETARCH&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;:-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;amd64&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;}&lt;/span&gt;/pilot-agent /usr/local/bin/pilot-agent

COPY stats-filter.wasm /etc/istio/extensions/stats-filter.wasm
COPY stats-filter.compiled.wasm /etc/istio/extensions/stats-filter.compiled.wasm
COPY metadata-exchange-filter.wasm /etc/istio/extensions/metadata-exchange-filter.wasm
COPY metadata-exchange-filter.compiled.wasm /etc/istio/extensions/metadata-exchange-filter.compiled.wasm

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# The pilot-agent will bootstrap Envoy.&lt;/span&gt;
ENTRYPOINT &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;/usr/local/bin/pilot-agent&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;csidecar-k8s&#34;&gt;C、Sidecar k8s&lt;/h3&gt;
&lt;h4 id=&#34;1基于docker进行注入&#34;&gt;1、基于docker进行注入&lt;/h4&gt;
&lt;p&gt;Kompose是个转换工具，可将 compose（即 Docker Compose）所组装的所有内容 转换成容器编排器（Kubernetes 或 OpenShift）可识别的形式。&lt;/p&gt;
&lt;p&gt;要将 docker-compose.yml 转换为 kubectl 可用的文件，请运行 kompose convert 命令进行转换，然后运行 kubectl create -f &lt;output file&gt; 进行创建。&lt;/p&gt;
&lt;h4 id=&#34;2控制面进行注入&#34;&gt;2、控制面进行注入&lt;/h4&gt;
&lt;h4 id=&#34;实现机制&#34;&gt;实现机制&lt;/h4&gt;
&lt;p&gt;K8S作为云原生操作系统的定位，其设计理念是&amp;quot;微内核&amp;quot;架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单体进程，往往采用Filter机制。&lt;/li&gt;
&lt;li&gt;分布式系统，通过webhook机制将自定义插件注入到分布式集群中。&lt;/li&gt;
&lt;li&gt;in-proxy模式，通过沙箱+远程脚本，实现非侵入性的单体进程内filter机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 的 apiserver 一开始就有 AdmissionController 的设计，这个设计和各类 Web 框架中的 Filter 很像，就是一个插件化的责任链，责任链中的每个插件针对 apiserver 收到的请求做一些操作或校验。分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MutatingWebhookConfiguration，操作 api 对象的， 会对request的resource，进行转换，比如填充默认的request/limit（有副作用）&lt;/li&gt;
&lt;li&gt;ValidatingWebhookConfiguration，校验 api 对象的, 比如校验Pod副本数必须大于2。（无副作用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kubernetes 中的许多高级功能需要启用准入控制器才能正确支持该功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://qiankunli.github.io/public/upload/kubernetes/admission_controller.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;k8s准入控制器&#34;&gt;K8S准入控制器&lt;/h4&gt;
&lt;p&gt;通过创建webhook资源，利用k8s的webhook能力实现pod的自动注入。&lt;/p&gt;
&lt;p&gt;基于 Kubernetes 的 突变 webhook 入驻控制器（mutating webhook addmission controller 的自动 sidecar 注入方式。&lt;/p&gt;
&lt;p&gt;实现流程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义webhook监听pod(node)&lt;/li&gt;
&lt;li&gt;注册到webhook(master)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;apiVersion&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;admissionregistration.k8s.io/v1&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;kind&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ValidatingWebhookConfiguration&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;metadata&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;pod-policy.example.com&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;webhooks&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;pod-policy.example.com&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;rules&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;apiGroups&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;apiVersions&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;operations&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;CREATE&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;resources&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;scope&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;       &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Namespaced&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;clientConfig&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;service&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;namespace&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;example-namespace&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;example-service&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;caBundle&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Ci0tLS0tQk...&amp;lt;base64-encoded PEM bundle containing the CA that signed the webhook&amp;#39;s serving certificate&amp;gt;...tLS0K&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;admissionReviewVersions&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v1beta1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;sideEffects&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;None&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;timeoutSeconds&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;自动化和规模化&#34;&gt;自动化和规模化&lt;/h4&gt;
&lt;p&gt;Kubernetes虽然提供了多种容器编排对象，例如Deployment、StatefulSet、DeamonSet、Job等，还有多种基础资源封装例如ConfigMap、Secret、Serivce等，但是一个应用往往有多个服务，有的可能还要依赖持久化存储，当这些服务之间直接互相依赖，需要有一定的组合的情况下，使用YAML文件的方式配置应用往往十分繁琐还容易出错，这时候就需要服务编排工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/istio/img_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写k8s资源文件集合&lt;/li&gt;
&lt;li&gt;通过打包格式进行管理&lt;/li&gt;
&lt;li&gt;上传到镜像仓库&lt;/li&gt;
&lt;li&gt;通过k8s包管理工具helm进行安装&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dsidecar-istio&#34;&gt;D、Sidecar istio&lt;/h3&gt;
&lt;h4 id=&#34;sidecar-injector-准入控制器&#34;&gt;sidecar injector 准入控制器&lt;/h4&gt;
&lt;p&gt;Istio 使用 ValidatingAdmissionWebhooks 验证 Istio 配置，使用 MutatingAdmissionWebhooks 自动将 Sidecar 代理注入至用户 Pod。&lt;/p&gt;
&lt;p&gt;它使用 MutatingWebhook 机制在 pod 创建的时候将 sidecar 的容器和卷添加到每个 pod 的模版里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/istio/img_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;containers&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;docker.io/istio/examples-bookinfo-productpage-v1:1.15.0&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# 应用镜像&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;productpage&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ports&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;containerPort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;9080&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;args&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;proxy&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;sidecar&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;domain&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;$(POD_NAMESPACE).svc.cluster.local&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;configPath&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;/etc/istio/proxy&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;binaryPath&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;/usr/local/bin/envoy&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;serviceCluster&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;productpage.$(POD_NAMESPACE)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;drainDuration&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;45s&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;parentShutdownDuration&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;1m0s&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;discoveryAddress&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;istiod.istio-system.svc:15012&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;zipkinAddress&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;zipkin.istio-system:9411&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;proxyLogLevel=warning&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;proxyComponentLogLevel=misc:error&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;connectTimeout&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;10s&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;proxyAdminPort&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;15000&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;concurrency&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;controlPlaneAuthPolicy&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;NONE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;dnsRefreshRate&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;300s&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;statusPort&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;15020&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;trust-domain=cluster.local&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- --&lt;span style=&#34;color:#000&#34;&gt;controlPlaneBootstrap=false&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;docker.io/istio/proxyv2:1.5.1&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# sidecar proxy&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;istio-proxy&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ports&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;containerPort&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;15090&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;http-envoy-prom&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;protocol&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TCP&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;initContainers&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;command&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;istio-iptables&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;p&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;15001&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;z&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;15006&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;u&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;1337&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;m&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#000&#34;&gt;REDIRECT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- -&lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;- &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;15090&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;15020&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;image&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;docker.io/istio/proxyv2:1.5.1&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;# init 容器&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;istio-init&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;配置管理设计&#34;&gt;配置管理设计&lt;/h4&gt;
&lt;h5 id=&#34;1-启动静态配置&#34;&gt;1. 启动静态配置&lt;/h5&gt;
&lt;p&gt;启动的最小配置集，可以和镜像集成在一起。&lt;/p&gt;
&lt;h5 id=&#34;2-静态自定义配置&#34;&gt;2. 静态自定义配置&lt;/h5&gt;
&lt;p&gt;可以使用K8S的静态配置进行配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;k8s config&lt;/li&gt;
&lt;li&gt;k8s crd&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-灵活的动态配置&#34;&gt;3. 灵活的动态配置&lt;/h5&gt;
&lt;p&gt;控制面下发，全量/增量推送：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;xDS&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;二istio-polit-agent&#34;&gt;二、Istio polit-agent&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Init 容器 istio-init：用于 pod 中设置 iptables 端口转发&lt;/li&gt;
&lt;li&gt;Sidecar 容器 istio-proxy：运行 sidecar 代理，如 Envoy 或 MOSN。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ucc.alicdn.com/pic/developer-ecology/99530825860d4c3aa80b58ac8e68d61b.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;init&#34;&gt;init&lt;/h4&gt;
&lt;p&gt;Init 容器是一种专用容器，它在应用程序容器启动之前运行，用来包含一些应用镜像中不存在的实用工具或安装脚本。&lt;/p&gt;
&lt;p&gt;一个 Pod 中可以指定多个 Init 容器，如果指定了多个，那么 Init 容器将会按顺序依次运行。只有当前面的 Init 容器必须运行成功后，才可以运行下一个 Init 容器。当所有的 Init 容器运行完成后，Kubernetes 才初始化 Pod 和运行应用容器。&lt;/p&gt;
&lt;p&gt;Init 容器使用 Linux Namespace，所以相对应用程序容器来说具有不同的文件系统视图。因此，它们能够具有访问 Secret 的权限，而应用程序容器则不能。&lt;/p&gt;
&lt;p&gt;在 Pod 启动过程中，Init 容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，将导致容器启动失败，它会根据 Pod 的 restartPolicy 指定的策略进行重试。然而，如果 Pod 的 restartPolicy 设置为 Always，Init 容器失败时会使用 RestartPolicy 策略。&lt;/p&gt;
&lt;p&gt;在所有的 Init 容器没有成功之前，Pod 将不会变成 Ready 状态。Init 容器的端口将不会在 Service中进行聚集。 正在初始化中的 Pod 处于 Pending 状态，但应该会将 Initializing 状态设置为 true。Init 容器运行完成以后就会自动终止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-4aa36ede4332a0b2d99005188c8056d4_1440w.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;aistio-sidecar-结构&#34;&gt;A、istio sidecar 结构&lt;/h3&gt;
&lt;h3 id=&#34;istio-init容器&#34;&gt;istio-init容器&lt;/h3&gt;
&lt;p&gt;该容器存在的意义就是让 sidecar 代理可以拦截所有的进出 pod 的流量，15090 端口（Mixer 使用）和 15092 端口（Ingress Gateway）除外的所有入站（inbound）流量重定向到 15006 端口（sidecar），再拦截应用容器的出站（outbound）流量经过 sidecar 处理（通过 15001 端口监听）后再出站。&lt;/p&gt;
&lt;h4 id=&#34;1-istio-iptables-进程&#34;&gt;1. istio-iptables 进程&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;istio-iptables &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;flags&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;
  -p: 指定重定向所有 TCP 流量的 sidecar 端口（默认为 &lt;span style=&#34;color:#000&#34;&gt;$ENVOY_PORT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; 15001）
  -m: 指定入站连接重定向到 sidecar 的模式，“REDIRECT” 或 “TPROXY”（默认为 &lt;span style=&#34;color:#000&#34;&gt;$ISTIO_INBOUND_INTERCEPTION_MODE&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;
  -b: 逗号分隔的入站端口列表，其流量将重定向到 Envoy（可选）。使用通配符 “*” 表示重定向所有端口。为空时表示禁用所有入站重定向（默认为 &lt;span style=&#34;color:#000&#34;&gt;$ISTIO_INBOUND_PORTS&lt;/span&gt;）
  -d: 指定要从重定向到 sidecar 中排除的入站端口列表（可选），以逗号格式分隔。使用通配符“*” 表示重定向所有入站流量（默认为 &lt;span style=&#34;color:#000&#34;&gt;$ISTIO_LOCAL_EXCLUDE_PORTS&lt;/span&gt;）
  -o：逗号分隔的出站端口列表，不包括重定向到 Envoy 的端口。
  -i: 指定重定向到 sidecar 的 IP 地址范围（可选），以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量。空列表将禁用所有出站重定向（默认为 &lt;span style=&#34;color:#000&#34;&gt;$ISTIO_SERVICE_CIDR&lt;/span&gt;）
  -x: 指定将从重定向中排除的 IP 地址范围，以逗号分隔的 CIDR 格式列表。使用通配符 “*” 表示重定向所有出站流量（默认为 &lt;span style=&#34;color:#000&#34;&gt;$ISTIO_SERVICE_EXCLUDE_CIDR&lt;/span&gt;）。
  -k：逗号分隔的虚拟接口列表，其入站流量（来自虚拟机的）将被视为出站流量。
  -g：指定不应用重定向的用户的 GID。&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;默认值与 -u param 相同&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;
  -u：指定不应用重定向的用户的 UID。通常情况下，这是代理容器的 UID（默认值是 1337，即 istio-proxy 的 UID）。
  -z: 所有进入 pod/VM 的 TCP 流量应被重定向到的端口（默认 &lt;span style=&#34;color:#000&#34;&gt;$INBOUND_CAPTURE_PORT&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; 15006）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;istio-proxy容器&#34;&gt;istio-proxy容器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2018/09/09/5b94b1c621c56.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用单容器多进程模型。&lt;/p&gt;
&lt;h4 id=&#34;1-pilot-agent进程&#34;&gt;1. pilot agent进程&lt;/h4&gt;
&lt;p&gt;在proxy镜像中，pilot-agent 负责的工作包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成envoy的配置：
&lt;ol&gt;
&lt;li&gt;与控制面板通讯，获取xDS配置&lt;/li&gt;
&lt;li&gt;生成 Envoy 的Bootstrap启动配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;启动envoy&lt;/li&gt;
&lt;li&gt;监控并管理envoy的运行状况
&lt;ol&gt;
&lt;li&gt;envoy健康检查&lt;/li&gt;
&lt;li&gt;envoy出错时pilot-agent负责重启envoy&lt;/li&gt;
&lt;li&gt;envoy配置变更后reload envoy&lt;/li&gt;
&lt;li&gt;envoy优雅退出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i1.wp.com/www.do1618.com/wp-content/uploads/2019/02/pilot-agent-arch.png?w=625&amp;amp;ssl=1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;status-server&#34;&gt;status server&lt;/h4&gt;
&lt;p&gt;[/pilot-agent/main/initStatusServer]&lt;/p&gt;
&lt;h4 id=&#34;envoy检查&#34;&gt;envoy检查&lt;/h4&gt;
&lt;p&gt;对于 ready 检查，调用的路径为/healthz/ready， 并配合设置的端口 applicationPorts 通过 Envoy 的 admin 端口进行对应的端口进行检查，用于决定 Envoy 是否已经 ready 接受相对应的流量。&lt;/p&gt;
&lt;p&gt;检查原理是通过本地管理端口，如 http://127.0.0.1:15000/listeners 获取 Envoy 当前监听的全部端口，然后将配置的端口 applicationPorts 在监听的端口中进行查找，来决定 Envoy 是否 ready。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/istio/img_0.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;应用端口检查&#34;&gt;应用端口检查&lt;/h4&gt;
&lt;p&gt;检查的路径为 /url 路径，在 header 中设置 istio-app-probe-port 端口，使用 访问路径中的 url 来进行检查，最终调用的是 http://127.0.0.1:istio-app-probe-port/url，头部设置的全部参数也都会传递到别检测的服务端口上；&lt;/p&gt;
&lt;h4 id=&#34;xds-proxy&#34;&gt;xds proxy&lt;/h4&gt;
&lt;p&gt;[/pilot-agent/main/istio_agent.NewAgent/initXdsProxy]&lt;/p&gt;
&lt;h4 id=&#34;2-proxy进程第三方代理进程&#34;&gt;2. proxy进程(第三方代理进程)&lt;/h4&gt;
&lt;h4 id=&#34;启动envoy&#34;&gt;启动Envoy&lt;/h4&gt;
&lt;p&gt;[/pilot-agent/main/istio_agent.NewAgent]&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/istio/img_1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;sidecar多进程设计模式&#34;&gt;sidecar多进程设计模式&lt;/h3&gt;
&lt;h4 id=&#34;1-开源集成&#34;&gt;1. 开源集成&lt;/h4&gt;
&lt;p&gt;代理属于第三方提供，istio是对其进行了管理和拓展。&lt;/p&gt;
&lt;p&gt;如果代理本身属于istio，是可以实现单进程模型。&lt;/p&gt;
&lt;h4 id=&#34;2-agent设计思想&#34;&gt;2. agent设计思想&lt;/h4&gt;
&lt;p&gt;由agent负责配置监听和下发。&lt;/p&gt;
&lt;p&gt;解耦配置管理和运行时，同时可以对proxy进程进行热重启。&lt;/p&gt;
&lt;h3 id=&#34;b流量拦截&#34;&gt;B、流量拦截&lt;/h3&gt;
&lt;h4 id=&#34;iptables&#34;&gt;iptables&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;ip netns exec cni-bf783dac-fe05-cb35-4d5a-848449119b19 iptables -L -t nat

-A PREROUTING -p tcp -j ISTIO_INBOUND                          # PREROUTING全部转发到INBOUND,PREROUTING发生在流入的数据包进入路由表之前
-A OUTPUT -p tcp -j ISTIO_OUTPUT                               # 由本机产生的数据向外转发的
-A ISTIO_INBOUND -p tcp -m tcp --dport 22 -j RETURN            # 22 15090  15021 15020的不转发到ISTIO_REDIRECT 
-A ISTIO_INBOUND -p tcp -m tcp --dport 15090 -j RETURN         
-A ISTIO_INBOUND -p tcp -m tcp --dport 15021 -j RETURN
-A ISTIO_INBOUND -p tcp -m tcp --dport 15020 -j RETURN
-A ISTIO_INBOUND -p tcp -j ISTIO_IN_REDIRECT                   # 剩余的流量都转发到ISTIO_REDIRECT
-A ISTIO_IN_REDIRECT -p tcp -j REDIRECT --to-ports 15006       # 转发到15006
-A ISTIO_OUTPUT -s 127.0.0.6/32 -o lo -j RETURN                # 127.0.0.6是InboundPassthroughBindIpv4,代表原地址是passthrough的流量都直接跳过,不劫持
-A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -m owner --uid-owner 1337 -j ISTIO_IN_REDIRECT  #lo网卡出流量,目标地址不是localhost的,且为同用户的流量进入ISTIO_IN_REDIRECT
-A ISTIO_OUTPUT -o lo -m owner ! --uid-owner 1337 -j RETURN    # lo网卡出流量 非同用户的不劫持
-A ISTIO_OUTPUT -m owner --uid-owner 1337 -j RETURN            # 剩下的同用户的都跳过
-A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -m owner --gid-owner 1337 -j ISTIO_IN_REDIRECT  # lo网卡出流量,目标地址非本地,同用户组的流量进入ISTIO_IN_REDIRECT
-A ISTIO_OUTPUT -o lo -m owner ! --gid-owner 1337 -j RETURN    # lo网卡出流量非同组的不劫持
-A ISTIO_OUTPUT -m owner --gid-owner 1337 -j RETURN            # 剩余的同用户的不劫持
-A ISTIO_OUTPUT -d 127.0.0.1/32 -j RETURN                      # 剩余的目标地址为127的不劫持
-A ISTIO_OUTPUT -j ISTIO_REDIRECT                              # 剩下的都进入 ISTIO_REDIRECT
-A ISTIO_REDIRECT -p tcp -j REDIRECT --to-ports 15001          # 转达到15001 outbond
COMMIT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/istio/img_4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s3.51cto.com/images/blog/202107/05/0a6870bdc35c1961ccb914fa63751dfc.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/envoy-sidecar-traffic-interception-zh-20210818.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.servicemesher.com/istio-handbook/images/envoy-traffic-route.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/iptables.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;三sidecar-发展&#34;&gt;三、Sidecar 发展&lt;/h2&gt;
&lt;h3 id=&#34;asidecar-流量交互&#34;&gt;A、sidecar 流量交互&lt;/h3&gt;
&lt;p&gt;要实现 应用容器(进程) 和 Sidecar容器(进程) 之间的交互。需要完成流量交互的功能。&lt;/p&gt;
&lt;h3 id=&#34;流量交互模式&#34;&gt;流量交互模式&lt;/h3&gt;
&lt;p&gt;对于跨容器(进程)的流量交互，主要有以下两种交互模式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;proxyless sidecar 和 Servicemesh 在方式上的差异：暴露 API 还是代理通讯协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;1-流量劫持-servicemesh&#34;&gt;1. 流量劫持 servicemesh&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Servicemesh 中，“零侵入”是一个非常强调的特性，为此不惜引入 iptables 等流量劫持方案。“零侵入”在某些特殊场景下会发挥巨大的优势，如旧有应用不做改造的前提下接入 servicemesh。好处自然不言而喻，但零侵入也有自身的限制：客户端必须能发出符合服务器端要求的网络通讯请求，这个过程外部无法插手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代理模式强调的是 原协议转发，应用进程无感。往往使用操作系统提供的流量劫持功能。&lt;/p&gt;
&lt;p&gt;适合于统一的网络协议栈（HTTP），仅实现原协议层面的控制（路由、重试等）。&lt;/p&gt;
&lt;p&gt;应用场景：envoy流量代理&lt;/p&gt;
&lt;p&gt;发展方向：内核高性能（eBPF）&lt;/p&gt;
&lt;h4 id=&#34;ebpf&#34;&gt;eBPF&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGnQGqr9ibU4uKLE7x8a0L48iaibekyLCc7BRPdN5wia28fe7SzrOGGzdlTzAuYOYHPXepdNYM1neIlOxA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;几乎没有开销是来自代理本身的逻辑。开销是通过注入代理，将网络流量重定向到它，终止连接和启动新的连接而增加的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGnQGqr9ibU4uKLE7x8a0L48iafV5EjtlibK6up9icGHXubrYicVWBeWsHTgL3wdWWFVqq6icIrR5fAEA5jw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGnQGqr9ibU4uKLE7x8a0L48ianSOrK1RicmJy8CmThERZC9m6Qch9QjP50Kp1dA0n9y2jSwegErrV07Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-流量明确指向-proxyless-sidecar&#34;&gt;2. 流量明确指向 proxyless sidecar&lt;/h4&gt;
&lt;p&gt;应用进程明确转发，协议自由切换，更丰富的应用层语义。往往使用grpc建立跨进程的链接。&lt;/p&gt;
&lt;p&gt;适合异构协议栈，支持更丰富的功能，支持协议之上应用层语义的控制。&lt;/p&gt;
&lt;p&gt;应用场景：multi runtime&lt;/p&gt;
&lt;p&gt;发展方向：grpc proxyless sidecar&lt;/p&gt;
&lt;h4 id=&#34;proxyless-sidecar&#34;&gt;proxyless sidecar&lt;/h4&gt;
&lt;p&gt;gRPC 项目对 xDS API 有很好的支持，也就是说你可以管理 gRPC 工作负载，而不需要同时部署 Envoy sidecar。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_jpg/06ULcDvaIGkFicB5CmUgMOuzpRGeOaPMSlYdnSibQFZkFD4TTbGYfJQq4bEuDBb2sl9zpR3771SXnjegj8khDq4A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;bmulti-sidecar&#34;&gt;B、multi sidecar&lt;/h3&gt;
&lt;p&gt;ServiceMesh 在微服务领域已经非常流行，越来越多的公司开始在内部落地，ServiceMesh 带来的业务解耦，平滑升级等优势大大提高了中间件的迭代效率。&lt;/p&gt;
&lt;p&gt;不过 ServiceMesh 只解决了服务间通讯的需求，而现实中的分布式应用存在更多的需求。而效仿 ServiceMesh 将应用需要的其他分布式能力外移到各种 Sidecar Runtime，这逐渐演变成了一个趋势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/images/ant-more-mesh_hu56c375bdd66e5b8ec5c7446e085ec97c_227360_1200x1200_fit_lanczos_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;与其依靠多个代理来实现不同的目的（例如网络代理，缓存代理，绑定代理），不如使用一个 Mecha 提供所有这些能力。&lt;/p&gt;
&lt;p&gt;Mecha 强调是“提供能力”，而不是通讯代理。&lt;/p&gt;
&lt;p&gt;Mecha 和 Micrologic 之间的交互是开放而有 API 标准的，Mecha 和 Micrologic 之间的“协议”体现在 API 上，而不是 TCP 通讯协议。这提供了一个契机：一个统一 Micrologic 和 Mecha 之间通讯方式的契机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/Pz6fSfK82D54JicV1tMvpmkrUqzsNfAKTxWChX3hiacPB5ohAWGhlxGocQ9kEoZAc3tFQfV26xKC0TDJiaToLnASw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;csidecar-拓展性&#34;&gt;C、sidecar 拓展性&lt;/h3&gt;
&lt;p&gt;面对千变万化的需求和复杂的应用环境，期望 Sidecar 本身的控制面和数据面来覆盖所有的场景显然是不现实的。强大、全面往往是因为&lt;strong&gt;易扩展&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;1-控制面拓展&#34;&gt;1. 控制面拓展&lt;/h4&gt;
&lt;p&gt;使用类似K8S webhook的机制，将自定义插件注入到控制面中，作为单独的服务执行。&lt;/p&gt;
&lt;p&gt;此类扩展可以完全无侵入的实现数据平面的增强。而且 API 的抽象屏蔽了数据平面的实现细节，扩展会具有更好的可移植性；独立进程执行和部署，具备更强的伸缩性。但是 webhook 模 也引入了大量额外的外部调用和数据交互，带来了巨大的性能开销。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.servicemesher.com/istio-handbook/images/ecosystem-webassembly-mixer.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-in-proxy拓展wasm&#34;&gt;2. in-proxy拓展（WASM）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*-ACRSpqbuJ0AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebAssembly，简称 WASM，是一个二进制指令集，最初是跑在浏览器上来解决 JavaScript 的性能问题，但由于它良好的安全性，隔离性以及语言无关性等优秀特性，很快人们便开始让它跑在浏览器之外的地方，随着 WASI 定义的出现，只需要一个 WASM 运行时，就可以让 WASM 文件随处执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;wasm和java字节码非常相似&#34;&gt;WASM和Java字节码非常相似&lt;/h4&gt;
&lt;p&gt;WASM 字节码不能直接在任何 CPU 架构上执行，但由于它与机器码非常相近，因此能够以非常快的速度被 WASM 引擎（或者也可以称之为 WASM 虚拟机）翻译为对应架构的机器码，获得和机器码相近的性能。&lt;/p&gt;
&lt;p&gt;WASM 本身是为 Web 而设计，因此天然具有跨平台支持；同时，通过 WASM 虚拟机的沙箱隔离，也使得执行 WASM 字节码相比于直接执行机器码有更高的安全性。&lt;/p&gt;
&lt;h4 id=&#34;envoy-wasm&#34;&gt;Envoy Wasm&lt;/h4&gt;
&lt;p&gt;Envoy 在可拓展性方面做了两方面的工作：&lt;/p&gt;
&lt;p&gt;第一，提供了名为 lua 的特殊扩展，允许控制面通过 xDS 协议动态下发 Lua 脚本并由 Envoy 解释执行。&lt;/p&gt;
&lt;p&gt;第二，也是本节的主题，Envoy 引入了 WASM 技术用于开发 Envoy 扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.servicemesher.com/istio-handbook/images/ecosystem-webassembly-envoy.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;istio-wasm&#34;&gt;Istio Wasm&lt;/h4&gt;
&lt;p&gt;Istio 的扩展机制使用 Proxy-Wasm 应用二进制接口（ABI）规范，提供了一套代理无关的流媒体 API 和实用功能，可以用任何有合适 SDK 的语言来实现。&lt;/p&gt;
&lt;p&gt;扩展 Istio 的功能，满足你的特定需求，需要三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Golang 中实现你的插件功能。&lt;/li&gt;
&lt;li&gt;编译、构建，并将 Wasm 模块推送到符合 OCI 标准的 Docker 镜像仓库。&lt;/li&gt;
&lt;li&gt;使用 WasmPlugin 资源配置服务网格工作负载，以便从远程镜像仓库中拉取 Wasm 模块。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;e其他&#34;&gt;E、其他&lt;/h3&gt;
&lt;h4 id=&#34;1-服务发现代理&#34;&gt;1. 服务发现代理&lt;/h4&gt;
&lt;p&gt;Mesh: dns拦截(udp)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.rocdu.top/20201117/role-of-dns-today.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://img.rocdu.top/20201117/dns-interception-in-istio.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: gRPC Landscape</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/01/21/grpc-landscape/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/01/21/grpc-landscape/</guid>
      <description>
        
        
        &lt;h2 id=&#34;一why-grpc&#34;&gt;一、Why gRPC?&lt;/h2&gt;
&lt;h3 id=&#34;cloud-native-interactive-landscape&#34;&gt;Cloud Native Interactive Landscape&lt;/h3&gt;
&lt;p&gt;CNCF 云原生景观全景图：https://landscape.cncf.io/?zoom=400&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/cloud-native.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;面对庞大的技术栈，有选择性的进行研究：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用上了解&lt;/li&gt;
&lt;li&gt;原理上了解&lt;/li&gt;
&lt;li&gt;设计上了解&lt;/li&gt;
&lt;li&gt;源码级了解&lt;/li&gt;
&lt;li&gt;参与贡献&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;application-layer&#34;&gt;Application layer&lt;/h3&gt;
&lt;p&gt;偏向 应用层 的技术栈：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/cloud-native-stack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;messaging&#34;&gt;messaging&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/messaging.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mesh&#34;&gt;mesh&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/mesh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;rpc&#34;&gt;rpc&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/rpc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;serverless-framework&#34;&gt;serverless framework&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/grpc/serverless.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;grpc&#34;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;云原生 应用层 技术栈，大量使用了gRPC作为网络通讯的协议/框架&lt;/p&gt;
&lt;h4 id=&#34;grpc-go&#34;&gt;gRPC-go&lt;/h4&gt;
&lt;p&gt;尤其是go-sdk，在大量sidecar模式架构中进行使用。&lt;/p&gt;
&lt;p&gt;Go语言gRPC技术栈&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://chai2010.gitbooks.io/advanced-go-programming-book/content/images/ch4-1-grpc-go-stack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;why-grpc&#34;&gt;Why gRPC?&lt;/h3&gt;
&lt;p&gt;鉴于 gRPC 在应用层技术栈的广泛使用和重要性，对其有源码级了解是有价值的。&lt;/p&gt;
&lt;h2 id=&#34;二grpc协议&#34;&gt;二、gRPC协议&lt;/h2&gt;
&lt;h3 id=&#34;设计原则&#34;&gt;设计原则&lt;/h3&gt;
&lt;p&gt;● 服务非对象、消息非引用 —— 促进微服务的系统间粗粒度消息交互设计理念，同时避免分布式对象的陷阱和分布式计算的谬误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;和 DCOM 及 EJB 完全相反的。只有数据，不包含逻辑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式计算谬误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络可靠；&lt;/li&gt;
&lt;li&gt;延迟为零；&lt;/li&gt;
&lt;li&gt;带宽是无限的；&lt;/li&gt;
&lt;li&gt;网络安全；&lt;/li&gt;
&lt;li&gt;拓扑不变；&lt;/li&gt;
&lt;li&gt;有一名管理员；&lt;/li&gt;
&lt;li&gt;运输成本为零；&lt;/li&gt;
&lt;li&gt;网络是同质的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 普遍并且简单 —— 该基础框架应该在任何流行的开发平台上适用，并且易于被个人在自己的平台上构建。它在CPU和内存有限的设备上也应该切实可行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;协议的设计应考虑全面的应用场景：边缘节点、serverless等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 免费并且开源 —— 所有人可免费使用基本特性。以友好的许可协议开源方式发布所有交付件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;避免具体技术锁定，应是可插拔的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;互通性&lt;/strong&gt; —— 该报文协议(Wire Protocol)必须遵循普通互联网基础框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同现有网络设施的兼容性和连通性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;over HTTP&lt;/li&gt;
&lt;li&gt;over TCP&lt;/li&gt;
&lt;li&gt;over UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 通用并且高性能 —— 该框架应该适用于绝大多数用例场景，相比针对特定用例的框架，该框架只会牺牲一点性能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;要通用性，不要极端性能优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 分层的 —— 该框架的关键是必须能够独立演进。对报文格式(Wire Format)的修改不应该影响应用层。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抽象的编程模型，与具体实现解耦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 负载无关的 —— 不同的服务需要使用不同的消息类型和编码，例如protocol buffers、JSON、XML和Thrift，协议上和实现上必须满足这样的诉求。类似地，对负载压缩的诉求也因应用场景和负载类型不同而不同，协议上应该支持可插拔的压缩机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Payload agnostic，RPC 框架不应该规定用的是什么 payload 格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;流&lt;/strong&gt; —— 存储系统依赖于流和流控来传递大数据集。像语音转文本或股票代码等其它服务，依靠流表达时间相关的消息序列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在某种程度上，可以将其理解为类似消息系统的消息队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.toutiao.io/c/df910edf0aca9dd3ba8387f2e767411d&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;● 阻塞式和非阻塞式 —— 支持异步和同步处理在客户端和服务端间交互的消息序列。这是在某些平台上缩放和处理流的关键。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用户态线程阻塞模型性能较差，应使用NIO编程模型，支持异步非阻塞式的交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;取消和超时&lt;/strong&gt; —— 有的操作可能会用时很长，客户端运行正常时，可以通过取消操作让服务端回收资源。当任务因果链被追踪时，取消可以级联。客户端可能会被告知调用超时，此时服务就可以根据客户端的需求来调整自己的行为。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持重置功能(RST_STREAM 帧)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;Lameducking&lt;/strong&gt; —— 服务端必须支持优雅关闭，优雅关闭时拒绝新请求，但继续处理正在运行中的请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优先级设计(Http2)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对流ID&lt;/li&gt;
&lt;li&gt;流级联设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;● &lt;strong&gt;流控&lt;/strong&gt; —— 在客户端和服务端之间，计算能力和网络容量往往是不平衡的。流控可以更好的缓冲管理，以及保护系统免受来自异常活跃对端的拒绝服务(DOS)攻击。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;维护缓冲区：窗口/背压/租约&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;基于HTTP2缓冲区的流控机制
基于应用层语义的流控&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 可插拔的 —— 数据传输协议(Wire Protocol)只是功能完备API基础框架的一部分。大型分布式系统需要安全、健康检查、负载均衡和故障恢复、监控、跟踪、日志等。实现上应该提供扩展点，以允许插入这些特性和默认实现。&lt;/p&gt;
&lt;p&gt;● API扩展 —— 可能的话，在服务间协作的扩展应该最好使用接口扩展，而不是协议扩展。这种类型的扩展可以包括健康检查、服务内省、负载监测和负载均衡分配。&lt;/p&gt;
&lt;p&gt;● 元数据交换 —— 常见的横切关注点，如认证或跟踪，依赖数据交换，但这不是服务公共接口中的一部分。部署依赖于他们将这些特性以不同速度演进到服务暴露的个别API的能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;metadata与payload分离&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;● 标准化状态码 —— 客户端通常以有限的方式响应API调用返回的错误。应该限制状态代码名字空间，使得这些错误处理决定更清晰。如果需要更丰富的特定域的状态，可以使用元数据交换机制来提供。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;● &lt;strong&gt;对端平等&lt;/strong&gt; —— 人机交互强调 客户端-&amp;gt;服务端 模型，机器之间交互任意一端都可作为客户端/服务端&lt;/p&gt;
&lt;p&gt;● &lt;strong&gt;长链接&lt;/strong&gt; —— 为服务端推送和双向流交互提供基础。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完善的应用层状态码命名空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;http2&#34;&gt;HTTP2&lt;/h3&gt;
&lt;h3 id=&#34;交互分析&#34;&gt;交互分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/H0HPgv9.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;li&gt;SETTINGS&lt;/li&gt;
&lt;li&gt;HEADERS&lt;/li&gt;
&lt;li&gt;DATA&lt;/li&gt;
&lt;li&gt;SETTINGS&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE&lt;/li&gt;
&lt;li&gt;PING&lt;/li&gt;
&lt;li&gt;HEADERS&lt;/li&gt;
&lt;li&gt;DATA&lt;/li&gt;
&lt;li&gt;HEADERS&lt;/li&gt;
&lt;li&gt;WINDOW_UPDATE&lt;/li&gt;
&lt;li&gt;PING&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;主链路&#34;&gt;主链路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;li&gt;Settings&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;流链路&#34;&gt;流链路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Settings&lt;/li&gt;
&lt;li&gt;Headers&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;Window_update&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;控制链路&#34;&gt;控制链路&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Window_update&lt;/li&gt;
&lt;li&gt;Ping&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.imgur.com/FrA8EW4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在建立连接之前，客户端/服务端都会发送连接前言（Magic+SETTINGS），确立协议和配置项。&lt;/li&gt;
&lt;li&gt;在传输数据时，是会涉及滑动窗口（WINDOW_UPDATE）等流控策略的。&lt;/li&gt;
&lt;li&gt;传播 gRPC 附加信息时，是基于 HEADERS 帧进行传播和设置；而具体的请求/响应数据是存储的 DATA 帧中的。&lt;/li&gt;
&lt;li&gt;请求/响应结果会分为 HTTP 和 gRPC 状态响应两种类型。&lt;/li&gt;
&lt;li&gt;客户端发起 PING，服务端就会回应 PONG，反之亦可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;grpc-1&#34;&gt;grpc&lt;/h3&gt;
&lt;h4 id=&#34;语义概念&#34;&gt;语义概念&lt;/h4&gt;
&lt;p&gt;gRPC 引入了三个新概念：通道、远程过程调用(RPC) 和消息。三者之间的关系很简单：每个通道可能有很多 RPC，而每个 RPC 可能有很多消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://grpc.io/img/channels_mapping_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://grpc.io/img/grpc_on_http2_mapping_2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;通道是 gRPC 中的一个关键概念。HTTP/2 中的流支持在单个连接上进行多个并发会话；通道通过在多个并发连接上启用多个流来扩展这个概念。&lt;/p&gt;
&lt;p&gt;通道代表到端点的虚拟连接，实际上可能由许多 HTTP/2 连接支持。RPC 与连接相关联。RPC 实际上是普通的 HTTP/2 流。消息与 RPC 相关联并作为 HTTP/2 数据帧发送。更具体地说，消息是在数据帧之上分层的。一个数据帧可能有很多 gRPC 消息，或者如果一个 gRPC 消息非常大它可能跨越多个数据帧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gRPC 对 16kb 的数据帧使用 HTTP/2 默认的最大大小。超过 16kb 的消息可能跨越多个数据帧，而低于该大小的消息可能与一些其他消息共享一个数据帧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;并非与http2强绑定&#34;&gt;并非与HTTP2强绑定？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Channel
&lt;ul&gt;
&lt;li&gt;Conns&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RPC
&lt;ul&gt;
&lt;li&gt;Conn&lt;/li&gt;
&lt;li&gt;Stream&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Message
&lt;ul&gt;
&lt;li&gt;Frame m:n&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三grpc框架&#34;&gt;三、gRPC框架&lt;/h2&gt;
&lt;h3 id=&#34;主链路-1&#34;&gt;主链路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;启动net server
*&lt;/li&gt;
&lt;li&gt;Stub
&lt;ul&gt;
&lt;li&gt;Contact
&lt;ul&gt;
&lt;li&gt;proto&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Channel
&lt;ul&gt;
&lt;li&gt;生命周期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;业务executor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Channel
&lt;ul&gt;
&lt;li&gt;创建ClientCall(RPC)&lt;/li&gt;
&lt;li&gt;将ClientCall转化成realCall(H2 Conn)&lt;/li&gt;
&lt;li&gt;将realCall转化成realStream (H2 Stream)&lt;/li&gt;
&lt;li&gt;执行realStream&lt;/li&gt;
&lt;li&gt;获取Response&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;H2 Conn:&lt;/p&gt;
&lt;p&gt;startCall&lt;/p&gt;
&lt;p&gt;call.sendMessage&lt;/p&gt;
&lt;p&gt;call.halfMessage&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844903984524705800&#34;&gt;https://juejin.cn/post/6844903984524705800&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/docs/what-is-grpc/core-concepts/&#34;&gt;https://grpc.io/docs/what-is-grpc/core-concepts/&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/blog/grpc-on-http2/&#34;&gt;https://grpc.io/blog/grpc-on-http2/&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/blog/yikyak/&#34;&gt;https://grpc.io/blog/yikyak/&lt;/a&gt;
&lt;a href=&#34;https://grpc.io/blog/grpc-load-balancing/&#34;&gt;https://grpc.io/blog/grpc-load-balancing/&lt;/a&gt;
&lt;a href=&#34;https://segmentfault.com/a/1190000019608421&#34;&gt;https://segmentfault.com/a/1190000019608421&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Blog: Capa: Mecha SDK of Cloud Application Api</title>
      <link>https://reactivegroup.github.io/capa.io/blog/2022/01/18/capa-mecha-sdk-of-cloud-application-api/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://reactivegroup.github.io/capa.io/blog/2022/01/18/capa-mecha-sdk-of-cloud-application-api/</guid>
      <description>
        
        
        &lt;h1 id=&#34;capacloud-application-api架起混合云应用开发的桥梁&#34;&gt;Capa(Cloud-Application-API)：架起混合云应用开发的桥梁&lt;/h1&gt;
&lt;p&gt;&amp;ldquo;让代码实现&amp;quot;一次编写，随处运行&amp;rdquo;。 借助Capa体系，使你的Java应用在改动量较小的情况下，拥有跨云、混合云运行的能力。&amp;quot;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者简介：
KevinTen，携程后端开发工程师，关注Reactive、RPC和云原生领域，对Mecha架构混合云中间件有深度实践经验。
Capa官方GitHub地址:&lt;a href=&#34;https://github.com/capa-cloud/capa-java&#34;&gt;https://github.com/capa-cloud/capa-java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在过去微服务的发展历程中，各大厂商基于SDK模式已经有相对完善的中间件体系。但在业务全球化、混合多云架构场景下，业务应用对基础设施的标准化和解耦、可迁移性以及拥抱开源成为新的诉求。
以当前的业界实践及趋势来看，ServiceMesh 这种 Sidecar 架构与体系是满足上述诉求的最佳实践。&lt;/p&gt;
&lt;p&gt;ServiceMesh 在微服务领域已经非常流行，越来越多的公司开始在内部落地，ServiceMesh 带来的业务解耦，平滑升级等优势大大提高了中间件的迭代效率。&lt;/p&gt;
&lt;p&gt;不过 ServiceMesh 只解决了服务间通讯的需求，而现实中的分布式应用存在更多的需求。而效仿 ServiceMesh 将应用需要的其他分布式能力外移到各种 Sidecar Runtime，这逐渐演变成了一个趋势。&lt;/p&gt;
&lt;p&gt;本文主要对 ServiceMesh 进行回顾总结，并分享业界基于 ServiceMesh 这种 Sidecar 模式解决混合云应用开发的解决方案，最后是关于混合云应用开发模式的探讨。&lt;/p&gt;
&lt;h2 id=&#34;一service-mesh-回顾与总结&#34;&gt;一、Service Mesh 回顾与总结&lt;/h2&gt;
&lt;h3 id=&#34;aservice-mesh-的初衷&#34;&gt;A、Service Mesh 的初衷&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*p8tGTbpLRegAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
在微服务架构下，基础架构团队一般会为应用提供一个封装了各种服务治理能力的 SDK，这种做法虽然保障了应用的正常运行，但缺点也非常明显，每次基础架构团队迭代一个新功能都需要业务方参与升级才能使用，尤其是 bugfix 版本，往往需要强推业务方升级，这里面的痛苦程度每一个基础架构团队成员都深有体会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;伴随着升级的困难，随之而来的就是应用使用的 SDK 版本差别非常大，生产环境同时跑着各种版本的 SDK，这种现象又会让新功能的迭代必须考虑各种兼容，就好像带着枷锁前进一般，这样随着不断迭代，会让代码维护非常困难，有些祖传逻辑更是一不小心就会掉坑里。&lt;/p&gt;
&lt;p&gt;同时这种“重”SDK 的开发模式，导致异构语言的治理能力非常薄弱，如果想为各种编程语言都提供一个功能完整且能持续迭代的 SDK 其中的成本可想而知。&lt;/p&gt;
&lt;p&gt;18 年的时候，Service Mesh 在国内持续火爆，这种架构理念旨在把服务治理能力跟业务解耦，让两者通过进程级别的通信方式进行交互。在这种架构模式下，服务治理能力从应用中剥离，运行在独立的进程中，迭代升级跟业务进程无关，这就可以让各种服务治理能力快速迭代，并且由于升级成本低，因此每个版本都可以全部升级，解决了历史包袱问题，同时 SDK 变“轻”直接降低了异构语言的治理门槛，再也不用为需要给各个语言开发相同服务治理能力的 SDK 头疼了。&lt;/p&gt;
&lt;h3 id=&#34;bservice-mesh-落地现状&#34;&gt;B、Service Mesh 落地现状&lt;/h3&gt;
&lt;h4 id=&#34;istio&#34;&gt;Istio&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/xokpWwTItyEW2YN4Iklmww&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;探索阶段：2017 年 - 2018 年&lt;/li&gt;
&lt;li&gt;早期采用者阶段：2019 年 - 2020 年&lt;/li&gt;
&lt;li&gt;大规模落地及生态发展阶段：2021 年至今&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果根据 “跨越鸿沟” 理论，服务网格已经跨越了 “鸿沟”，处于 “早期大众” 和 “晚期大众” 阶段之间。根据《Istio 大咖说》 观众中的反馈来看，用户已不再盲从于新技术，开始辩证的考虑 是否真的需要引入服务网格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/service-mesh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mson&#34;&gt;Mson&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*rRG_TYlHMqYAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
蚂蚁很快意识到了 Service Mesh 的价值，全力投入到这个方向，用 Go 语言开发了 MOSN 这样可以对标 envoy 的优秀数据面，全权负责服务路由，负载均衡，熔断限流等能力的建设，大大加快了公司内部落地 Service Mesh 的进度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在 MOSN 在蚂蚁内部已经覆盖了数千个应用、数十万容器，新创建的应用默认接入 MOSN，形成闭环。而且在大家最关心的资源占用、性能损耗方面 MOSN 也交出了一份让人满意的答卷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;RT 小于 0.2ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 占用增加 0%~2%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存消耗增长小于 15M&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Service Mesh 降低了异构语言的服务治理门槛，NodeJS、C++等异构技术栈也在持续接入到 MOSN 中。&lt;/p&gt;
&lt;p&gt;在看到 RPC 能力 Mesh 化带来的巨大收益之后，蚂蚁内部还把 MQ，Cache，Config 等中间件能力都进行了 Mesh 化改造，下沉到 MOSN，提高了中间件产品整体的迭代效率。&lt;/p&gt;
&lt;h3 id=&#34;c新的挑战&#34;&gt;C、新的挑战&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Mesh化是云原生落地的关键步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最下方是云，以kubernetes为核心，关于这一点社区基本已经达成共识：kubernetes 就是云原生下的操作系统，屏蔽了不同云的软硬件差异。&lt;/li&gt;
&lt;li&gt;在kubernetes之上，是Mesh层。不仅仅有我们熟悉的 ServiceMesh，还有诸如Database Mesh和Message Mesh等类似的其他 Mesh 产品形态，这些Mesh组成了一个标准化的通信层。&lt;/li&gt;
&lt;li&gt;运行在各种 Mesh 的应用，不管是微服务形态，还是传统非微服务形态，都可以借助Mesh的帮助实现应用轻量化。非业务逻辑的各种功能被剥离到Mesh中后，应用得以“瘦身减负”。&lt;/li&gt;
&lt;li&gt;瘦身之后的应用，其内容主要是业务逻辑实现。这样的工作负载形式，更适合 serverless 的要求，为接下来转型 serverless 做好准备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/images/ant-more-mesh_hu56c375bdd66e5b8ec5c7446e085ec97c_227360_1200x1200_fit_lanczos_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;x-mesh&#34;&gt;X Mesh&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://skyao.io/talk/201910-ant-finance-service-mesh-deep-practice/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*nKxcTKLp4EoAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
一个现代分布式应用，往往会同时依赖 RPC、Cache、MQ、Config 等各种分布式能力来完成业务逻辑的处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当初看到 RPC 下沉的红利以后，其他各种能力也都快速下沉。&lt;/p&gt;
&lt;p&gt;初期，大家都会以自己最熟悉的方式来开发，这就导致没有统一的规划管理，如上图所示，应用依赖了各种基础设施的 SDK，而每种 SDK 又以自己特有的方式跟 MOSN 进行交互，使用的往往都是由原生基础设施提供的私有协议，这直接导致了复杂的中间件能力虽然下沉，但应用本质上还是被绑定到了基础设施。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中间件抽象不足&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如想把缓存从 Redis 迁移到 Memcache 的话，仍旧需要业务方升级 SDK，这种问题在应用上云的大趋势下表现的更为突出。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;应用跟基础设施强绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;试想一下，如果一个应用要部署在云上，由于该应用依赖了各种基础设施，势必要先把整个基础设施搬到云上才能让应用顺利部署，这其中的成本可想而知。
因此如何让应用跟基础设施解绑，使其具备可移植能力，能够无感知跨平台部署是我们面临的第一个问题。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;异构语言接入成本高&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*oIdQQZmgtyUAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
事实证明 Service Mesh 确实降低了异构语言的接入门槛，但在越来越多的基础能力下沉到 MOSN 以后，我们逐渐意识到为了让应用跟 MOSN 交互，各种 SDK 里都需要对通信协议，序列化协议进行开发，如果再加上需要对各种异构语言都提供相同的功能，那维护难度就会成倍上涨，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Service Mesh 让重 SDK 成为了历史，但对于现在各种编程语言百花齐放、各种应用又强依赖基础设施的场景来说，我们发现现有的 SDK 还不够薄，异构语言接入的门槛还不够低，如何进一步降低异构语言的接入门槛是我们面临的第二个问题。&lt;/p&gt;
&lt;h2 id=&#34;二multi-runtime-理论概述&#34;&gt;二、Multi Runtime 理论概述&lt;/h2&gt;
&lt;h3 id=&#34;a什么是-runtime&#34;&gt;A、什么是 Runtime?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*hQT-Spc5rI4AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
20 年初的时候，Bilgin lbryam 发表了一篇名为
Multi-Runtime Microservices Architecture
的文章，里面对微服务架构下一阶段的形态进行了讨论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上图所示，作者把分布式服务的需求进行了抽象，总共分为了四大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;生命周期（Lifecycle）
主要指应用的编译、打包、部署等事情，在云原生的大趋势下基本被 docker、kubernetes 承包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络（Networking）
可靠的网络是微服务之间进行通信的基本保障，Service Mesh 正是在这方面做了尝试，目前 MOSN、envoy 等流行的数据面的稳定性、实用性都已经得到了充分验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态（State）
分布式系统需要的服务编排，工作流，分布式单例，调度，幂等性，有状态的错误恢复，缓存等操作都可以统一归为底层的状态管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定（Binding）
在分布式系统中，不仅需要跟其他系统通信，还需要集成各种外部系统，因此对于协议转换，多种交互模型、错误恢复流程等功能也都有强依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;明确了需求以后，借鉴了 Service Mesh 的思路，作者对分布式服务的架构演进进行了如下总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*rwS2Q5yMp_sAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
第一阶段就是把各种基础设施能力从应用中剥离解耦，通通变成独立 sidecar 模型伴随着应用一起运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二阶段是把各种 sidecar 提供的能力统一抽象成若干个 Runtime，这样应用从面向基础组件开发就演变成了面向各种分布式能力开发，彻底屏蔽掉了底层实现细节，而且由于是面向能力，除了调用提供各种能力的 API 之外，应用再也不需要依赖各种各样基础设施提供的 SDK 了。&lt;/p&gt;
&lt;p&gt;作者的思路跟我们希望解决的问题一致，我们决定使用 Runtime 的理念来解决 Service Mesh 发展到现在所遇到的新问题。&lt;/p&gt;
&lt;h3 id=&#34;bservice-mesh-vs-runtime&#34;&gt;B、Service Mesh vs Runtime&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*srPVSYTEHc4AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
为了让大家对 Runtime 有一个更加清晰的认识，上图针对 Service Mesh 跟 Runtime 两种理念的定位、交互方式、通信协议以及能力丰富度进行了总结，可以看到相比 Service Mesh 而言，Runtime 提供了语义明确、能力丰富的 API，可以让应用跟它的交互变得更加简单直接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/cloud-native-stack.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三multi-runtime-落地实践&#34;&gt;三、Multi Runtime 落地实践&lt;/h2&gt;
&lt;h3 id=&#34;adapr&#34;&gt;A、dapr&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/93/93ccecd9a241b5c6921b988b18f0362e.png&#34; alt=&#34;&#34;&gt;
dapr 是社区中一款知名的 Runtime 实现产品，活跃度也比较高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://docs.dapr.io/images/overview-sidecar-model.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供了多种分布式能力，API 定义清晰，基本能满足一般的使用场景。&lt;/li&gt;
&lt;li&gt;针对各种能力都提供了不同的实现组件，基本涵盖了常用的中间件产品，用户可以根据需要自由选择。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;控制平面&#34;&gt;控制平面&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://skyao.io/talk/202103-dapr-from-servicemesh-to-cloudnative/images/dapr-control-plane_hu32ec8c339282b281cdff3c71662e3695_1613641_1200x1200_fit_lanczos_3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;和service-mesh共存&#34;&gt;和Service Mesh共存&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://docs.dapr.io/concepts/service-mesh/#using-dapr-with-a-service-mesh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://docs.dapr.io/images/service-mesh.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;当考虑如何在已使用Service Mesh公司内部落地 dapr 时，提出了两种方案，如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;替换：废弃掉现在的Istio，用 dapr 进行替换，这种方案存在两个问题：&lt;/p&gt;
&lt;p&gt;a.  dapr 虽然提供了很多分布式能力，但目前并不具备 Service Mesh 包含的丰富的服务治理能力。&lt;/p&gt;
&lt;p&gt;b.  Istio 已经大规模落地，并且经过了考验，直接用 dapr 来替换 Istio 稳定性有待验证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共存：新增一个 dapr 容器，跟 Istio 以两个 sidecar 的模式进行部署。这种方案同样存在两个问题：&lt;/p&gt;
&lt;p&gt;a.  引入一个新的 sidecar，我们就需要考虑它配套的升级、监控、注入等等事情，运维成本飙升。&lt;/p&gt;
&lt;p&gt;b.  多维护一个容器意味着多了一层挂掉的风险，这会降低现在的系统可用性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;blayotto&#34;&gt;B、Layotto&lt;/h3&gt;
&lt;p&gt;同样的，如果你目前正在使用 envoy 作为数据面，也会面临上述问题。&lt;/p&gt;
&lt;p&gt;因此我们希望把 Runtime 跟 Service Mesh 两者结合起来，通过一个完整的 sidecar 进行部署，在保证稳定性、运维成本不变的前提下，最大程度复用现有的各种 Mesh 能力。此外我们还希望这部分 Runtime 能力除了跟 Istio 结合起来之外，未来也可以跟 envoy 结合起来，解决更多场景中的问题，Layotto 就是在这样的背景下诞生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*sdGoSYB_XFUAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
如上图所示，Layotto 是构建在 MOSN 之上，在下层对接了各种基础设施，向上层应用提供了统一的，具有各种各样分布式能力的标准 API。对于接入 Layotto 的应用来说，开发者不再需要关心底层各种组件的实现差异，只需要关注应用需要什么样的能力，然后调用对应能力的 API 即可，这样可以彻底跟底层基础设施解绑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对应用来说，交互分为两块，一个是作为 gRPC Client 调用 Layotto 的标准 API，一个是作为 gRPC Server 来实现 Layotto 的回调，得利于gRPC 优秀的跨语言支持能力，应用不再需要关心通信、序列化等细节问题，进一步降低了异构技术栈的使用门槛。&lt;/p&gt;
&lt;p&gt;除了面向应用，Layotto 也向运维平台提供了统一的接口，这些接口可以把应用跟 sidecar 的运行状态反馈给运维平台，方便 SRE 同学及时了解应用的运行状态并针对不同状态做出不同的举措，该功能考虑到跟 k8s 等已有的平台集成，因此我们提供了 HTTP 协议的访问方式。&lt;/p&gt;
&lt;p&gt;除了 Layotto 本身设计以外，项目还涉及两块标准化建设，首先想要制定一套语义明确，适用场景广泛的 API 并不是一件容易的事情，为此我们跟阿里、 dapr 社区进行了合作，希望能够推进 Runtime API 标准化的建设，其次对于 dapr 社区已经实现的各种能力的 Components 来说，我们的原则是优先复用、其次开发，尽量不把精力浪费在已有的组件上面，重复造轮子。&lt;/p&gt;
&lt;p&gt;最后 Layotto 目前虽然是构建在 MOSN 之上，未来我们希望 Layotto 可以跑在 envoy 上，这样只要应用接入了 Service Mesh，无论数据面使用的是 MOSN 还是 envoy，都可以在上面增加 Runtime能力。&lt;/p&gt;
&lt;h3 id=&#34;ccapa&#34;&gt;C、Capa&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Capa主要为了解决携程混合云部署开发的问题，主要面向Java技术栈。
github: &lt;a href=&#34;https://github.com/capa-cloud/capa-java&#34;&gt;https://github.com/capa-cloud/capa-java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Capa项目基于Mecha架构的设计理念，使用 富SDK模式 提供Multi-Runtime的标准API。&lt;/p&gt;
&lt;p&gt;您可以简单的将Capa项目理解为 Dapr / Layotto 等Sidecar模式项目的SDK实现版本。&lt;/p&gt;
&lt;h4 id=&#34;sidecar-or-sdk&#34;&gt;Sidecar or SDK&lt;/h4&gt;
&lt;p&gt;基于Mecha架构理念的Multi-Runtime，以Sidecar的方式提供标准API的功能，看起来似乎是最合理的选择。&lt;/p&gt;
&lt;p&gt;那为什么不直接使用Dapr/Layotto等项目，而是选择开发 富SDK模式 的Capa项目呢。&lt;/p&gt;
&lt;p&gt;概括：以Dapr为代表的Sidecar架构是未来，但现有的很多企业和系统很难一步到位的升级到Sidecar架构，富SDK架构将会长期的存在下去。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sidecar的开发和运维成本高。&lt;/li&gt;
&lt;li&gt;sidecar中实现自定义逻辑的复杂度高。&lt;/li&gt;
&lt;li&gt;当前sidecar模式还不足够成熟，无法短时间内完成开发和部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引申：面对庞大的Java系统体系，Capa项目将使用富SDK模型支持Java系统向Mecha架构过渡。在Dapr等项目成熟后，也可以无缝衔接到Sidecar架构。&lt;/p&gt;
&lt;h4 id=&#34;能力水平模型&#34;&gt;能力水平模型&lt;/h4&gt;
&lt;p&gt;选用sidecar来进行中间件支持，存在以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在过去我们积累了丰富的Java SDK，全盘舍弃意味着巨大的损失。&lt;/li&gt;
&lt;li&gt;社区还比较年轻，短时间内用golang重写所有SDK逻辑不太现实。&lt;/li&gt;
&lt;li&gt;社区对公有云功能支持比较好，私有云主要依赖SDK模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/feature-support.png&#34; alt=&#34;img.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SDK模式的缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨语言开发和维护成本高。无法支撑多语言战略，团队没有精力维护除了 Java 以外其他语言的 SDK；&lt;/li&gt;
&lt;li&gt;SDK升级侵入性强。客户端 SDK 版本升级推进困难，特别是遇到 Bug 的时候，彻底下线一个版本可能会花上几个月的时间，给业务带来了隐患；&lt;/li&gt;
&lt;li&gt;依赖冲突&lt;/li&gt;
&lt;li&gt;&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;capa-sdk设计&#34;&gt;Capa SDK设计&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://github.com/dapr/dapr/issues/3261&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设计思路：标准API + 可拔插可替换的SDK组件 模式&lt;/p&gt;
&lt;p&gt;在不同的分布式中间件领域，Capa提供与具体中间件API无关的统一的标准编程API。 所以应用程序在使用Capa编程时不需要依赖任何具体的中间件API，只需要依赖Capa的标准编程API即可。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;Mono&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Void&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;client&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;publishEvent&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;mytopic&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;my message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在部署到不同的目标环境时，Capa将会装载标准API的不同实现类到应用程序中。当调用统一的编程API时，底层运行时会适配到不同的具体中间件SDK实现。&lt;/p&gt;
&lt;p&gt;中间件团队需要针对不同目标环境，开发标准API在目标环境下的实现类即可；而应用代码可以拥有&amp;quot;一次编写，随处运行&amp;quot;的开发体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/22876610/120766251-9ef56200-c54c-11eb-9fc2-15b17937b4bb.PNG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;示例capa-java--maven&#34;&gt;示例：Capa-java + Maven&lt;/h4&gt;
&lt;p&gt;核心实现思想就是：面向接口编程 + 通过JavaSPI动态加载实现类&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-sdk.png&#34; alt=&#34;capa-sdk&#34;&gt;&lt;/p&gt;
&lt;p&gt;Maven配置伪代码示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;!-- 编程时直接引入API层 --&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;group.rxcloud&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;capa-sdk&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;!-- AWS云实现类 --&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;aws&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependencys&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;group.rxcloud&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;capa-sdk-aws&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;  
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependencys&amp;gt;&lt;/span&gt;

    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;!-- Ali云实现类 --&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;ali&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependencys&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;group.rxcloud&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;capa-sdk-ali&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependencys&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开发人员编程时，应用程序直接调用API层的接口进行编程。&lt;/p&gt;
&lt;p&gt;在打包成镜像的过程中，通过maven profile加载不同云平台的jar实现。&lt;/p&gt;
&lt;p&gt;在运行时，SDK通过Java SPI机制，动态加载API层接口的实现类。
该实现类，即为各个云平台上不同的SDK实现。&lt;/p&gt;
&lt;h3 id=&#34;dfemas--opensergo--micro--other--&#34;&gt;D、Femas / OpenSergo / Micro / Other / &amp;hellip;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://www.yuque.com/docs/share/5221c27a-9d0c-44c7-8ef2-0956d3b09a32?#&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.nlark.com/yuque/0/2021/png/12961124/1632385886671-69b482d2-eef9-498d-a036-021e3810e6ee.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/69c8695b4a1c5440d798343bb4b86128b7b733d60b67605f7476c099616f9dd8/68747470733a2f2f6d6963726f2e6d752f696d616765732f6d6963726f2d332e302e706e67&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;e移植性&#34;&gt;E、移植性&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*2DrSQJ6GL8cAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
如上图所示，一旦完成 Runtime API 的标准化建设，接入 Mecha 的应用天然具备了可移植性，应用不需要任何改造就可以在私有云以及各种公有云上部署，并且由于使用的是标准 API，应用也可以无需任何改造就在 Layotto / dapr / Capa 之间自由切换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;未来迁移&#34;&gt;未来迁移&lt;/h4&gt;
&lt;p&gt;SDK模式的优点在于开发和接入的成本较低，可以快速拥有混合云部署开发的能力。但缺点也是无法忽视的，当随着Mecha Runtime的发展，未来SDK模式很可能将会迁移到更有技术优势的Mecha Runtime Sidecar模式中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但也要考虑到性能敏感领域，例如分布式缓存领域。相关模块能接受额外 1ms 的响应延迟吗？Sidecar 带来的优势能否弥补这个问题？
所以in-process(SDK)模型在这些领域仍具备不可替代的优势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推动API的标准化建设：使各大Mecha体系保持API层的统一，保留未来互相迁移的可能。&lt;/p&gt;
&lt;p&gt;从未来几年来看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在较小的私有云，会长期支持SDK模式。&lt;/li&gt;
&lt;li&gt;在较大的私有云，框架团队有能力完成大规模sidecar化改造，会从SDK模式迁移到Sidecar模式。&lt;/li&gt;
&lt;li&gt;在公有云，目前可以选用SDK模式/Sidecar模式，SDK模式更有利于二次定制；&lt;/li&gt;
&lt;li&gt;随着社区在公有云能力的发展，以及云厂商的支持，未来可全部切换到sidecar模式。&lt;/li&gt;
&lt;li&gt;对于异构语言架构，可对主要语种采用sdk模式(功能更丰富)，小语种采用sidecar模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四api设计原则&#34;&gt;四、API设计原则&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;就像SQL标准之于关系型数据库。&lt;/p&gt;
&lt;p&gt;参考资料：https://www.infoq.cn/article/wjkNGoGaaHyKs7xIyTSB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;a功能集选择&#34;&gt;A、功能集选择&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/api-design.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;组件提供的能力不平齐&#34;&gt;组件提供的能力不平齐&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/29/298af0137732cd1fb526bd46229a71fc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;解决思路一runtime-弥补组件缺失能力sidecar&#34;&gt;解决思路一：Runtime 弥补组件缺失能力（sidecar）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/ca/caa5f9fc42715d24967cbeed433bd870.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;解决思路二component-弥补组件缺失能力&#34;&gt;解决思路二：Component 弥补组件缺失能力&lt;/h4&gt;
&lt;h4 id=&#34;capa示例configuration&#34;&gt;Capa示例：Configuration&lt;/h4&gt;
&lt;p&gt;在私有云的Configuraion-java-sdk(如apollo/qconfig)中，sdk本身支持监听配置变化。&lt;/p&gt;
&lt;p&gt;但在AWS AppConfig java sdk中，本身并不支持监听配置变化。&lt;/p&gt;
&lt;p&gt;那我们认为对于configuraion中间件领域而言，监听配置变化是level0的功能，是必须具有的功能。&lt;/p&gt;
&lt;p&gt;所以需要在component-sdk中对其进行弥补：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sdk中通过定时线程+轮询接口的方式，获取最新的配置变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以此，使用户接入时，认为具有这项能力。&lt;/p&gt;
&lt;h4 id=&#34;解决思路三无法弥补但可以模糊处理&#34;&gt;解决思路三：无法弥补，但可以模糊处理&lt;/h4&gt;
&lt;p&gt;能力分层模型：A云能够实现，B云通过其他方式也能实现。&lt;/p&gt;
&lt;h4 id=&#34;解决思路四无法弥补又不能模糊处理&#34;&gt;解决思路四：无法弥补又不能模糊处理&lt;/h4&gt;
&lt;p&gt;高危，按条件选用。 明确告知在特定云上才有这项能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;社区讨论：协商机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;b分层模型&#34;&gt;B、分层模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/2a/2a92f5f1dd7d8dae44df981e3afa5368.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;c拓展字段&#34;&gt;C、拓展字段&lt;/h3&gt;
&lt;p&gt;高度定制化。不建议用户直接使用。&lt;/p&gt;
&lt;p&gt;若要用，则使用定义好的有限枚举。
SDK实现中对该枚举进行支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static001.geekbang.org/wechat/images/39/391a3a9fa724a81fb53ac409adb4e3f9.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;e配置原语&#34;&gt;E、配置原语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://github.com/dapr/dapr/issues/2988&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*mfkRQZH3oNwAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
首先是分布式系统中经常使用的配置功能，应用一般使用配置中心来做开关或者动态调整应用的运行状态。Layotto 中配置模块的实现包括两部分，一个是对如何定义配置这种能力的 API 的思考，一个是具体的实现，下面逐个来看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想要定义一个能满足大部分实际生产诉求的配置 API 并不是一件容易的事，dapr 目前也缺失这个能力，因此我们跟阿里以及 dapr 社区一起合作，为如何定义一版合理的配置 API 进行了激烈讨论。&lt;/p&gt;
&lt;p&gt;目前讨论结果还没有最终确定，因此 Layotto 是基于我们提给社区的第一版草案进行实现，下面对我们的草案进行简要说明。&lt;/p&gt;
&lt;p&gt;我们先定义了一般配置所需的基本元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;appId：表示配置属于哪个应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key：配置的 key&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;content：配置的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;group：配置所属的分组，如果一个 appId 下面的配置过多，我们可以给这些配置进行分组归类，便于维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外我们追加了两种高级特性，用来适配更加复杂的配置使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;label，用于给配置打标签，比如该配置属于哪个环境，在进行配置查询的时候，我们会使用 label + key 来查询配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tags，用户给配置追加的一些附加信息，如描述信息、创建者信息，最后修改时间等等，方便配置的管理，审计等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于上述定义的配置 API 的具体实现，目前支持查询、订阅、删除、创建、修改五种操作，其中订阅配置变更后的推送使用的是 gRPC 的 stream 特性，而底层实现这些配置能力的组件，我们选择了国内流行的 apollo，后面也会根据需求增加其他实现。&lt;/p&gt;
&lt;p&gt;level1&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1582369/112835954-8d1abd00-90cc-11eb-9426-f26e14fb984f.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;level2&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1582369/112836063-ae7ba900-90cc-11eb-8617-0939b13b6c40.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;levelx&amp;hellip;&lt;/p&gt;
&lt;p&gt;metadata&lt;/p&gt;
&lt;h3 id=&#34;grpc-原语&#34;&gt;G、RPC 原语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*i-JnSaeZbJ4AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
RPC 的能力大家不会陌生，这可能是微服务架构下最最基础的需求，对于 RPC 接口的定义，我们同样参考了 dapr 社区的定义，发现完全可以满足我们的需求，因此接口定义就直接复用 dapr 的，但目前 dapr 提供的 RPC 实现方案还比较薄弱，而 MOSN 经过多年迭代，能力已经非常成熟完善，因此我们大胆把 Runtime 跟 Service Mesh 两种思路结合在一起，把 MOSN 本身作为我们实现 RPC 能力的一个 Component，这样 Layotto 在收到 RPC 请求以后交给 MOSN 进行实际数据传输，这种方案可以通过 istio 动态改变路由规则，降级限流等等设置，相当于直接复用了 Service Mesh 的各种能力，这也说明 Runtime 不是要推翻 Service Mesh，而是要在此基础上继续向前迈一步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-rpc.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;五capa-实践&#34;&gt;五、Capa 实践&lt;/h2&gt;
&lt;h3 id=&#34;a适配迁移之痛&#34;&gt;A、适配迁移之痛&lt;/h3&gt;
&lt;p&gt;如果要使用原生的Capa API，您的遗留系统需要面对较大的重构工作量。&lt;/p&gt;
&lt;p&gt;为了使迁移做到低成本，我们可以复用目前使用到的中间件API。&lt;/p&gt;
&lt;p&gt;通过开发一个适配层项目(提供相同的注解/接口调用方式)，将原中间件API的实现更改为Capa API。&lt;/p&gt;
&lt;p&gt;如此一来，应用程序只需要更改很少的代码(例如更换注解/接口的路径名)即可迁移到Capa架构。&lt;/p&gt;
&lt;p&gt;目前在Java语言上，Capa可以支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接入(携程)私有云SDK的适配层&lt;/li&gt;
&lt;li&gt;接入spring boot体系的适配层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-use.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;接入适配模式的改动范围&#34;&gt;接入适配模式的改动范围&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;替换中间件依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.ctrip.framework.apollo&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;apollo-client&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;to&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;group.rxcloud&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;capa-sdk-configuration&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;替换相关代码（import路径+注解名）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;com.ctrip.framework.apollo.Config&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@Config&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;testjson.json&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;person&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;to&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;group.rxcloud.capa.config.CloudConfig&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@CloudConfig&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;testjson.json&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;person&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Q: 为什么不保持import路径和使用方式完全一致？&lt;/p&gt;
&lt;p&gt;A: 当运行在特定云上时，需要加载对应的sdk进来；这时如果有类路径完全一致的类存在，会导致类加载冲突。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;bcapa-api设计&#34;&gt;B、Capa API设计&lt;/h3&gt;
&lt;p&gt;Capa(Java SDK)是面向Java应用实现Mecha架构的SDK解决方案，它目前支持以下领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service Invocation (RPC服务调用)&lt;/li&gt;
&lt;li&gt;Configuration Centor (Configuration动态配置)&lt;/li&gt;
&lt;li&gt;Publish/Subscribe (Pub/Sub发布订阅)&lt;/li&gt;
&lt;li&gt;State Management (State状态管理)&lt;/li&gt;
&lt;li&gt;Application Log/Metrics/Traces (Telemetry可观测性)&lt;/li&gt;
&lt;li&gt;Redis (Redis高度定制化存储) -beta&lt;/li&gt;
&lt;li&gt;Database (SQL关系型数据库) -alpha&lt;/li&gt;
&lt;li&gt;Schedule (Schedule定时调度) -alpha&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;完全复用的标准api&#34;&gt;完全复用的标准API&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Service Invocation (RPC服务调用)&lt;/li&gt;
&lt;li&gt;Configuration Centor (Configuration动态配置)&lt;/li&gt;
&lt;li&gt;Publish/Subscribe (Pub/Sub发布订阅)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;补充了的标准api&#34;&gt;补充了的标准API&lt;/h3&gt;
&lt;h4 id=&#34;rpc&#34;&gt;RPC&lt;/h4&gt;
&lt;p&gt;标准API中只涵盖了作为Client调用其他服务的API。&lt;/p&gt;
&lt;p&gt;但不同云上服务注册的框架弈有所不同（例如：dubbo/spring cloud/service mesh)。&lt;/p&gt;
&lt;p&gt;在sidecar模式中，sidecar本身可类似service mesh一样承担服务注册的能力，通过callback API调用服务接口，但SDK模式时却不行。&lt;/p&gt;
&lt;p&gt;所以添加了作为服务端的API：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// -- Runtime as Server
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * Register onInvoke method when runtime as server.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param &amp;lt;T&amp;gt;            The Type of the request type, use byte[] to skip serialization.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param &amp;lt;R&amp;gt;            The Type of the response type, use byte[] to skip serialization.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param methodName     The actual Method to be call in the application.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param httpExtensions Additional fields that are needed if the receiving app is listening on                       HTTP, {@link HttpExtension#NONE} otherwise.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param onInvoke       the on invoke
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param metadata       Metadata (in GRPC) or headers (in HTTP) to be received in request.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @return A Mono Plan of register result.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Mono&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Boolean&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;registerMethod&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;methodName&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;HttpExtension&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;httpExtensions&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;
                                        &lt;span style=&#34;color:#000&#34;&gt;Function&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;R&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;onInvoke&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;
                                        &lt;span style=&#34;color:#000&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;metadata&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * Register controller class when runtime as server.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param registerServerRequest the register server request
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @return A Mono Plan of register result.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Mono&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Boolean&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;registerServer&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RegisterServerRequest&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;registerServerRequest&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-rpc-server.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;pubsub&#34;&gt;PubSub&lt;/h4&gt;
&lt;p&gt;标准API中定义了Pub发布消息的API，而Sub订阅消息则通过callback进行定义。&lt;/p&gt;
&lt;p&gt;sidecar通过callback回调触发Sub订阅，但对于SDK模式而言，并没有额外的进程可触发callback逻辑。&lt;/p&gt;
&lt;p&gt;所以添加了消息订阅的API：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// -- Runtime as Subscriber
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * Subscribe events.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param pubsubName the pubsub name we will subscribe the event from.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param topicName  the topicName where the event will be subscribed.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param metadata   The metadata for the subscription.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @return a Flux stream of subscription events.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Flux&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TopicEventRequest&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;subscribeEvents&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;pubsubName&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;topicName&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;metadata&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * Subscribe events.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param topicSubscription the request for topic subscription.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @return a Flux stream of subscription events.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Flux&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TopicEventRequest&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;subscribeEvents&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;TopicSubscription&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;topicSubscription&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;未使用的标准api&#34;&gt;未使用的标准API&lt;/h3&gt;
&lt;h4 id=&#34;state-management-state状态管理&#34;&gt;State Management (State状态管理)&lt;/h4&gt;
&lt;p&gt;目前KV主要使用的Redis。&lt;/p&gt;
&lt;p&gt;而标准State API，可表达的语义较弱，无法cover redis场景。&lt;/p&gt;
&lt;p&gt;所以暂时未使用。&lt;/p&gt;
&lt;h4 id=&#34;distributed-lock-api-分布式锁&#34;&gt;Distributed Lock API (分布式锁)&lt;/h4&gt;
&lt;p&gt;规划中。&lt;/p&gt;
&lt;p&gt;但对于跨云环境而言，很难做到全局锁，只能做到Region/云级别的锁。&lt;/p&gt;
&lt;h4 id=&#34;sequencer-api-全局uuid&#34;&gt;Sequencer API (全局UUID)&lt;/h4&gt;
&lt;p&gt;目前在java中，直接使用本地进程内算法实现。&lt;/p&gt;
&lt;h4 id=&#34;file-api-文件系统&#34;&gt;File API (文件系统)&lt;/h4&gt;
&lt;p&gt;规划中。&lt;/p&gt;
&lt;p&gt;后续应该会做，因为不同云上的文件系统使用方式不同。&lt;/p&gt;
&lt;h4 id=&#34;secret-api-密钥存储&#34;&gt;Secret API (密钥存储)&lt;/h4&gt;
&lt;p&gt;规划中。&lt;/p&gt;
&lt;p&gt;后续可能会做，因为不同云上密钥存储使用方式不同。&lt;/p&gt;
&lt;p&gt;但目前密钥存储还未暴露给用户使用，而只是中间件在使用，所以中间件中直接引用了对应云的SDK来实现。&lt;/p&gt;
&lt;h3 id=&#34;自定义的非标准api&#34;&gt;自定义的非标准API&lt;/h3&gt;
&lt;p&gt;目前的 dapr api 并不能在保持可移植性的同时满足现实世界中应用程序的所有需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：https://github.com/mosn/layotto/issues/530&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;db-sql&#34;&gt;DB SQL&lt;/h4&gt;
&lt;p&gt;对于SQL而言：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SQL协议已经十分成熟&lt;/li&gt;
&lt;li&gt;将SQL抽象为一套API，面临的挑战很多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;故Capa目前仅提供了一套待讨论的SQL API: &lt;a href=&#34;https://github.com/dapr/dapr/issues/3354&#34;&gt;dapr【提案】数据库API设计 #3354&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而在落地实践过程中，SQL关系型数据库领域采用的方案是
&lt;a href=&#34;https://github.com/ctripcorp/dal&#34;&gt;DAL&lt;/a&gt; 数据库连接技术，经二次开发支持混合云SDK模式。&lt;/p&gt;
&lt;h4 id=&#34;redis&#34;&gt;Redis&lt;/h4&gt;
&lt;p&gt;目前的State API，无法支持复杂的Redis语义表达。
故Capa在Redis领域，基于 Jedis 定义了一套 &lt;a href=&#34;https://github.com/capa-cloud/cloud-runtimes-jvm/blob/develop/cloud-runtimes-api/src/main/java/group/rxcloud/cloudruntimes/domain/enhanced/RedisRuntimes.java&#34;&gt;Redis API&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;telemetry-logmetrictrace&#34;&gt;Telemetry (Log/Metric/Trace)&lt;/h4&gt;
&lt;p&gt;场景：中间件SDK/应用程序 需要记录指标埋点。&lt;/p&gt;
&lt;p&gt;之前，我们可以通过 CAT 这类应用监控告警平台进行实现。&lt;/p&gt;
&lt;p&gt;Capa复用了 OpenTelemetry 的API，来实现监控告警/指标收集的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-telemetry-api.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;schedule&#34;&gt;Schedule&lt;/h4&gt;
&lt;p&gt;场景：触发job调度任务（规划中）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; * Schedule Bindings Runtimes standard API defined.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ScheduleRuntimes&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * Invokes a Schedule Binding operation.
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     *
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param appId    the app id
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param jobName  the job name
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @param metadata the metadata
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     * @return the job flux stream
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;     */&lt;/span&gt;
    &lt;span style=&#34;color:#000&#34;&gt;Flux&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Object&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;invokeSchedule&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;appId&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;jobName&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Map&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;metadata&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;c云原生技术栈选型&#34;&gt;C、云原生技术栈选型&lt;/h3&gt;
&lt;p&gt;Capa SDK本身不具有丰富的功能，更像是一个包装适配层，具体功能由下层的具体中间件来实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;领域&lt;/th&gt;
&lt;th&gt;云厂商&lt;/th&gt;
&lt;th&gt;技术选型&lt;/th&gt;
&lt;th&gt;实践经验&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RPC&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;Trip SOA&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;AWS AppMesh&lt;/td&gt;
&lt;td&gt;重试、熔断、超时等全部从SDK中下沉到Mesh层处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Configuration&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;Apollo / &lt;a href=&#34;https://github.com/qunarcorp/qconfig&#34;&gt;QConfig&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;AWS AppConfig&lt;/td&gt;
&lt;td&gt;功能较为简陋，需要在SDK中进行弥补&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MQ&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;(https://github.com/qunarcorp/qmq)&#34;&gt;QMQ&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;AWS MSK Kafka&lt;/td&gt;
&lt;td&gt;缺少如延时消息等功能，需要借助周边系统进行弥补&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;CRedis&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;AWS ElasticCache&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Log/Metric/Trace&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;CAT&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;AWS CloudWatch&lt;/td&gt;
&lt;td&gt;OpenTelemetryAPI对接CloudWatch SDK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DB(SQL)&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/ctripcorp/dal&#34;&gt;DAL&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;非Mecha架构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;DAL + AWS RDS&lt;/td&gt;
&lt;td&gt;非Mecha架构&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Schedule&lt;/td&gt;
&lt;td&gt;Trip&lt;/td&gt;
&lt;td&gt;QSchedule&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;AWS&lt;/td&gt;
&lt;td&gt;K8S cronJob&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;d个性化的配置和逻辑&#34;&gt;D、个性化的配置和逻辑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-plugin.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序可以覆写 配置 ，实现自定义&lt;/li&gt;
&lt;li&gt;应用程序可以覆写 插件 ，实现自定义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-plugin-config.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;自定义配置类似layotto：&lt;a href=&#34;https://github.com/mosn/layotto/issues/500&#34;&gt;layotto 配置下发通道与配置热加载 #500&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;特定云的配置&#34;&gt;特定云的配置&lt;/h4&gt;
&lt;p&gt;集成在对应云的SDK中。&lt;/p&gt;
&lt;h4 id=&#34;举个例子layotto-解耦api跟具体实现-513httpsgithubcommosnlayottoissues513&#34;&gt;举个例子：&lt;a href=&#34;https://github.com/mosn/layotto/issues/513&#34;&gt;layotto 解耦API跟具体实现 #513&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;如果用户在调用API时明确指定了，使用redis作为store_name，那么对于没有部署redis的云平台，则无法运行。&lt;/p&gt;
&lt;p&gt;所以对于redis这种与基础设施有关的选择，capa并不暴露给用户：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;store_name，存放在sdk的配置文件中。&lt;/li&gt;
&lt;li&gt;用户通过一个接口方法(比如getStoreName())，获取该name，并透传给API调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要也是因为，capa当前都是1:1的情况，目前不存在1个领域有多种实现。&lt;/p&gt;
&lt;p&gt;后续如果有这种情况，考虑使用configuration配置功能进行映射：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个configuration配置，key1=redis, key2=mongo&lt;/li&gt;
&lt;li&gt;用户发起了两次调用，两次调用分别为例如key1=1, key2=2&lt;/li&gt;
&lt;li&gt;则getStoreName(key1)=redis，getStoreName(key1)=mongodb，默认=redis&lt;/li&gt;
&lt;li&gt;用户将此store_name透传给API调用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;应用个性化的配置和逻辑&#34;&gt;应用个性化的配置和逻辑&lt;/h4&gt;
&lt;p&gt;SDK中的一些逻辑是可替换的，实现上通过面向Java接口编程，在SDK中提供了接口的默认实现。&lt;/p&gt;
&lt;p&gt;应用程序可以通过覆盖接口实现，从而实现自定义逻辑。&lt;/p&gt;
&lt;h3 id=&#34;e跨云交互&#34;&gt;E、跨云交互&lt;/h3&gt;
&lt;p&gt;一方面在进行混合云改造的过程中，面临过渡期的问题。
当一部分的服务和数据在原云平台上时，新云平台将面临和原云平台进行交互的问题。&lt;/p&gt;
&lt;p&gt;另一方面作为混合云架构，若要发挥每个云各自的优势，有可能不同服务会部署在不同的云平台上，这时也会面对跨云交互的问题。&lt;/p&gt;
&lt;p&gt;而要实现跨云交互，主要由以下两个思路：&lt;/p&gt;
&lt;h4 id=&#34;1-由mecha-runtime解决跨云交互问题&#34;&gt;1. 由Mecha Runtime解决跨云交互问题&lt;/h4&gt;
&lt;p&gt;Mecha Runtime/SDK感知混合云，并实现跨云交互。&lt;/p&gt;
&lt;p&gt;但可能实现起来比较复杂，设计到跨云的认证、网络打通等。&lt;/p&gt;
&lt;h4 id=&#34;2-capa由外部插件周边系统完成跨云交互部分的功能&#34;&gt;2. (Capa)由外部插件/周边系统，完成跨云交互部分的功能&lt;/h4&gt;
&lt;p&gt;Mecha Runtime/SDK将会比较轻量，不需要感知其他云。
涉及到某个领域的跨云交互问题，交由该领域的 基础设施/周边系统 完成。&lt;/p&gt;
&lt;p&gt;Capa相比于layotto等sidecar模型，采用SDK模式更不易引入较复杂逻辑，会导致SDK过于臃肿，且无法多语言复用。
故Capa架构中，所有跨云交互问题，都交由具体领域的周边系统完成，Capa只关注于当前云的配置和使用。&lt;/p&gt;
&lt;h4 id=&#34;rpc服务调用跨云&#34;&gt;RPC服务调用跨云&lt;/h4&gt;
&lt;p&gt;跨云服务调用的前提是，网络层面流量已经打通。
例如在AWS上，通过PrivateLink技术进行网络流量打通。&lt;/p&gt;
&lt;p&gt;之后在服务调用中，依赖网络基础的流量转发实现:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RPC网络基础设施&lt;/th&gt;
&lt;th&gt;跨云交互能力&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;K8S&lt;/td&gt;
&lt;td&gt;ExternalService转发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Istio&lt;/td&gt;
&lt;td&gt;ServiceEntry转发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dubbo/SpringCloud/Trip SOA&lt;/td&gt;
&lt;td&gt;MockService转发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AWS AppMesh&lt;/td&gt;
&lt;td&gt;VirtualNode DNS转发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不支持？&lt;/td&gt;
&lt;td&gt;搭建Nginx代理实现转发&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-rpc-crose.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mq跨云&#34;&gt;MQ跨云&lt;/h4&gt;
&lt;p&gt;使用周边系统：MQ同步工具，进行跨云消息传输。&lt;/p&gt;
&lt;p&gt;按需申请，消息格式转换，失败重试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/capa-mq-crose.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;数据跨云&#34;&gt;数据跨云&lt;/h4&gt;
&lt;p&gt;DB数据使用周边系统：&lt;a href=&#34;https://github.com/ctripcorp/drc&#34;&gt;MySQL同步工具&lt;/a&gt; ，进行跨云数据传输。&lt;/p&gt;
&lt;p&gt;Redis数据目前不做跨云传输。&lt;/p&gt;
&lt;h4 id=&#34;configuration等&#34;&gt;Configuration等&lt;/h4&gt;
&lt;p&gt;使用周边系统：XX同步工具，进行跨云的数据同步。&lt;/p&gt;
&lt;h2 id=&#34;六高阶拓展&#34;&gt;六、高阶拓展&lt;/h2&gt;
&lt;h3 id=&#34;awebassembly-的探索&#34;&gt;A、WebAssembly 的探索&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*-ACRSpqbuJ0AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
WebAssembly，简称 WASM，是一个二进制指令集，最初是跑在浏览器上来解决 JavaScript 的性能问题，但由于它良好的安全性，隔离性以及语言无关性等优秀特性，很快人们便开始让它跑在浏览器之外的地方，随着 WASI 定义的出现，只需要一个 WASM 运行时，就可以让 WASM 文件随处执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然 WebAssembly 可以在浏览器以外的地方运行，那么我们是否能把它用在 Serverless 领域？目前已经有人在这方面做了一些尝试，不过如果这种方案真的想落地的话，首先要考虑的就是如何解决运行中的 WebAssembly 对各种基础设施的依赖问题。&lt;/p&gt;
&lt;h4 id=&#34;webassembly-落地原理&#34;&gt;WebAssembly 落地原理&lt;/h4&gt;
&lt;p&gt;目前 MOSN 通过集成 WASM Runtime 的方式让 WASM 跑在 MOSN 上面，以此来满足对 MOSN 做自定义扩展的需求。同时，Layotto 也是构建在 MOSN 之上，因此我们考虑把二者结合在一起，实现方案如下图所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*U7UDRYyBOvIAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
开发者可以使用 Go/C++/Rust 等各种各样自己喜欢的语言来开发应用代码，然后把它们编译成 WASM 文件跑在 MOSN 上面，当 WASM 形态的应用在处理请求的过程中需要依赖各种分布式能力时就可以通过本地函数调用的方式调用 Layotto 提供的标准 API，这样直接解决了 WASM 形态应用的依赖问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前 Layotto 提供了 Go 跟 Rust 版 WASM 的实现，虽然只支持 demo 级功能，但已经足够让我们看到这种方案的潜在价值。&lt;/p&gt;
&lt;p&gt;此外，WASM 社区目前还处于初期阶段，有很多地方需要完善，我们也给社区提交了一些 PR共同建设，为 WASM 技术的落地添砖加瓦。&lt;/p&gt;
&lt;h4 id=&#34;webassembly-落地展望&#34;&gt;WebAssembly 落地展望&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*NzwKRY2GZPcAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
虽然现在 Layotto 中对 WASM 的使用还处于试验阶段，但我们希望它最终可以成为 Serverless 的一种实现形态，如上图所示，应用通过各种编程语言开发，然后统一编译成 WASM 文件，最后跑在 Layotto+MOSN 上面，而对于应用的运维管理统一由 k8s、docker、prometheus 等产品负责。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;用户实现自定义的逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于中间件领域，可以由社区定义一套执行模板，而用户可以灵活的插入自定义的回调逻辑，更具有动态扩展性。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;隔离中间件运行时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Runtime启动多个相互隔离的 WASM Runtime ，从而隔离每个中间件组件的运行时（CPU/内存/&amp;hellip;)，避免异常的扩散和传播，互不影响。&lt;/p&gt;
&lt;h4 id=&#34;istio-wasm&#34;&gt;Istio Wasm&lt;/h4&gt;
&lt;p&gt;Istio 的扩展机制使用 Proxy-Wasm 应用二进制接口（ABI）规范，提供了一套代理无关的流媒体 API 和实用功能，可以用任何有合适 SDK 的语言来实现。&lt;/p&gt;
&lt;p&gt;扩展 Istio 的功能，满足你的特定需求，需要三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Golang 中实现你的插件功能。&lt;/li&gt;
&lt;li&gt;编译、构建，并将 Wasm 模块推送到符合 OCI 标准的 Docker 镜像仓库。&lt;/li&gt;
&lt;li&gt;使用 WasmPlugin 资源配置服务网格工作负载，以便从远程镜像仓库中拉取 Wasm 模块。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/VAwTCIP6RhqDNoBbmE8zVA&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;wasm-展望&#34;&gt;Wasm 展望&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;支持网络接口&lt;/li&gt;
&lt;li&gt;对go-sdk有更好的支持，现在以c/rust为主。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bebpf-的探索&#34;&gt;B、eBPF 的探索&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/iptables.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ebpf-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ebpf-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/W9NySdKnxuQ6S917QQn3PA&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;应用场景-sidecar加速&#34;&gt;应用场景: sidecar加速&lt;/h4&gt;
&lt;p&gt;socket重定向，绕过TCP/IP协议栈，&lt;/p&gt;
&lt;h2 id=&#34;七社区规划&#34;&gt;七、社区规划&lt;/h2&gt;
&lt;p&gt;最后来看下社区的做的一些事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://zhuanlan.zhihu.com/p/435012312?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=618742049890111488&amp;amp;utm_content=group2_article&amp;amp;utm_campaign=shareopn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;a建设更多的api标准&#34;&gt;A、建设更多的API标准&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*OpQTRqoMpK0AAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
上图列出了 Layotto 跟 dapr 现有的能力对比，在 Layotto 的开发过程中，我们借鉴 dapr 的思路，始终以优先复用、其次开发为原则，旨在达成共建的目标，而对于正在建设或者未来要建设的能力来说，我们计划优先在 Layotto 上落地，然后再提给社区，合并到标准 API，鉴于社区异步协作的机制，沟通成本较高，因此短期内可能 Layotto 的 API 会先于社区，但长期来看一定会统一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分布式锁API&lt;/li&gt;
&lt;li&gt;文件系统API&lt;/li&gt;
&lt;li&gt;延迟消息API&lt;/li&gt;
&lt;li&gt;密钥管理API&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bapi-标准化建设&#34;&gt;B、API 标准化建设&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://gw.alipayobjects.com/mdn/rms_1c90e8/afts/img/A*GAe8QqZ03eoAAAAAAAAAAAAAARQnAQ&#34; alt=&#34;&#34;&gt;
关于如何定义一套标准的 API 以及如何让 Layotto 可以跑在 envoy 上等等事项，我们已经在各个社区进行了深入讨论，并且以后也还会继续推进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于 API 标准化的建设是一件需要长期推动的事情，同时标准化意味着不是满足一两种场景，而是尽可能的适配大多数使用场景。&lt;/p&gt;
&lt;h3 id=&#34;c可扩展api架构&#34;&gt;C、可扩展API架构&lt;/h3&gt;
&lt;p&gt;参考OS领域当年是怎么定API的，我们可以把Runtime API设计成多层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;社区标准API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;企业内部的私有API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基础设施特定API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分别对应OS领域的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POSIX API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各种Unix-like系统自己的System Call&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊硬件提供的特殊功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这种思想，尝试让Runtime支持API插件，让用户自己实现自己的私有API&lt;/p&gt;
&lt;h3 id=&#34;d直接支持行业标准协议&#34;&gt;D、直接支持行业标准协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接支持SQL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接支持Redis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要进一步讨论。&lt;/p&gt;
&lt;h3 id=&#34;e开源协同&#34;&gt;E、开源协同&lt;/h3&gt;
&lt;p&gt;各个Mecha项目积极交流，合作共建，互为补充。&lt;/p&gt;
&lt;h2 id=&#34;八云厂商的支持&#34;&gt;八、云厂商的支持&lt;/h2&gt;
&lt;h3 id=&#34;a阿里云在内部的落地&#34;&gt;A、阿里云在内部的落地&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://blog.dapr.io/posts/2021/03/19/how-alibaba-is-using-dapr/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;微服务架构faas-与-多语言应用&#34;&gt;微服务架构、Faas 与 多语言应用&lt;/h4&gt;
&lt;p&gt;微服务架构分层逐渐形成，后端 BaaS 化，客户端轻量化，业务侧 Serverless 化，让业务更加聚焦业务开发，进一步提升研发效率。&lt;/p&gt;
&lt;p&gt;FaaS 对多语言支持的需求强烈，并不局限于 Java。但实际上，由于成本和时间限制，用所有语言重新开发客户是不切实际的。&lt;/p&gt;
&lt;p&gt;借助 Dapr，阿里巴巴解决了 FaaS 的多语言问题，帮助客户通过 FaaS 提高开发效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ali-dapr.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dapr/dapr/issues/3169&#34;&gt;Are you using Dapr? #3169&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;适配基于java的遗留系统&#34;&gt;适配基于Java的遗留系统&lt;/h4&gt;
&lt;p&gt;我们旨在消除业务开发团队进行代码更改以减少迁移期间对业务应用程序的影响的需要。在将这些遗留系统迁移到 Dapr 时，我们设计了一个 Java 适配层，它将原始 Java 调用适配到 Dapr 客户端 API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.dapr.io/posts/2021/03/19/how-alibaba-is-using-dapr/multiple-langurage_hu5d98ca782c8bcb789c89210a0f8e3e46_207793_1500x0_resize_q75_box.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;混合云云到云迁移&#34;&gt;混合云：云到云迁移&lt;/h4&gt;
&lt;p&gt;Dapr 的可移植性将钉钉文档的上层应用与消息系统等底层基础设施解耦。从而，钉钉文档实现了不同云平台之间的平滑迁移。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blog.dapr.io/posts/2021/03/19/how-alibaba-is-using-dapr/cloud-migration_hu5d98ca782c8bcb789c89210a0f8e3e46_276395_1500x0_resize_q75_box.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;b蚂蚁集团mesh化进展&#34;&gt;B、蚂蚁集团Mesh化进展&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;参考文章：https://mp.weixin.qq.com/s/eh0Jz7YeF27bXqdBMd4MPw&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;1soa-时代&#34;&gt;1、SOA 时代&lt;/h4&gt;
&lt;p&gt;中间件的客户端，均直接集成在业务进程内：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ant-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2mesh-化阶段&#34;&gt;2、Mesh 化阶段&lt;/h4&gt;
&lt;p&gt;中间件能力下沉，应用和基础设施实现部分解耦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ant-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3应用运行时阶段&#34;&gt;3.应用运行时阶段&lt;/h4&gt;
&lt;p&gt;将应用和具体基础设施的类型解耦，仅依赖标准 API 编程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/ant-3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;c微软azure的托管支持&#34;&gt;C、微软Azure的托管支持&lt;/h3&gt;
&lt;p&gt;微软在 Ignite 2021 大会上发布了预览版的Azure Container Apps，这是一个完全托管的无服务器容器运行时，用于大规模构建和运行现代应用程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用分布式应用运行时 Dapr 轻松构建和连接微服务。 Dapr允许你构建松耦合的微服务应用程序，而不是构建一个分布式单体应用，在Azure Container Apps里我，利用 Dapr 及其组件构建具有弹性、可扩展性和松耦合的应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://www.cnblogs.com/shanyou/p/15509042.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ddaprlayotto-加入-cncf-孵化器&#34;&gt;D、Dapr/Layotto 加入 CNCF 孵化器&lt;/h3&gt;
&lt;p&gt;CNCF 托管了许多与 Dapr 紧密结合的项目。例如，Dapr 使用 gRPC 作为它的主要 RPC 堆栈。OpenTelemetry 用作 Dapr 的遥测协议，CloudEvents 用于标准化 Dapr 的 Pub/Sub API 中的消息格式，SPIFFE 用作 Dapr 的访问列表特性的身份格式，Prometheus 用作 Dapr 端点的指标格式，Dapr 支持 NATS 的 Pub/Sub 实现以及 Open Policy Agent。此外，Dapr 使用 Operator 在 Kubernetes 上原生运行，并使用 Helm 作为主要部署机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考资料：https://mp.weixin.qq.com/s/8qnmL12JrESwJg3RsSelJQ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/capa-cloud/capa.io/master/content/images/zh/blog/news/capa/slog.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;主要参考文献&#34;&gt;主要参考文献&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mosn.io/layotto/#/zh/blog/mosn-subproject-layotto-opening-a-new-chapter-in-service-grid-application-runtime/index&#34;&gt;https://mosn.io/layotto/#/zh/blog/mosn-subproject-layotto-opening-a-new-chapter-in-service-grid-application-runtime/index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/N3dzDc4QvtvCZytBh46PLw&#34;&gt;https://mp.weixin.qq.com/s/N3dzDc4QvtvCZytBh46PLw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
